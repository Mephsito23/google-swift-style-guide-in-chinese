<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Swift Style Guide 中文版</title>
  <meta name="description" content="Google's Swift style guide.
">

  <link rel="stylesheet" href="/google-swift-style-guide-in-chinese/css/main.css">
  <link rel="canonical" href="http://stage.swift.gg/google-swift-style-guide-in-chinese//google-swift-style-guide-in-chinese/">
  <link rel="alternate" type="application/rss+xml" title="Google Swift Style Guide 中文版" href="http://stage.swift.gg/google-swift-style-guide-in-chinese//google-swift-style-guide-in-chinese/feed.xml">
</head>


<body>

  <main role="main">
    <article class="page">
  <header>
    <h1>Swift Style Guide 中文版</h1>
  </header>
  <!--  -->
<style>
article pre {
    overflow: visible;
}
</style>

<p>This style guide is based on Apple’s excellent Swift standard library style and
also incorporates feedback from usage across multiple Swift projects within
Google. It is a living document and the basis upon which the formatter is
implemented.</p>

<p>这份代码风格指南是基于优秀的 Apple Swift 标准库代码风格，并吸取了多个 Google 内部 Swift 项目的使用反馈而成。本文档会保持更新，并且已经基于本文档实现了格式化工具。</p>

<h2 class="no_toc" id="目录table-of-contents">目录/Table of Contents</h2>

<ul id="markdown-toc">
  <li><a href="#源文件基础source-file-basics" id="markdown-toc-源文件基础source-file-basics">源文件基础/Source File Basics</a>    <ul>
      <li><a href="#文件名file-names" id="markdown-toc-文件名file-names">文件名/File Names</a></li>
      <li><a href="#文件编码file-encoding" id="markdown-toc-文件编码file-encoding">文件编码/File Encoding</a></li>
      <li><a href="#空白符whitespace-characters" id="markdown-toc-空白符whitespace-characters">空白符/Whitespace Characters</a></li>
      <li><a href="#特殊转义字符special-escape-sequences" id="markdown-toc-特殊转义字符special-escape-sequences">特殊转义字符/Special Escape Sequences</a></li>
      <li><a href="#不可见字符和修饰符invisible-characters-and-modifiers" id="markdown-toc-不可见字符和修饰符invisible-characters-and-modifiers">不可见字符和修饰符/Invisible Characters and Modifiers</a></li>
      <li><a href="#字符串字面量string-literals" id="markdown-toc-字符串字面量string-literals">字符串字面量/String Literals</a></li>
    </ul>
  </li>
  <li><a href="#源文件结构source-file-structure" id="markdown-toc-源文件结构source-file-structure">源文件结构/Source File Structure</a>    <ul>
      <li><a href="#文件注释file-comments" id="markdown-toc-文件注释file-comments">文件注释/File Comments</a></li>
      <li><a href="#导入语句import-statements" id="markdown-toc-导入语句import-statements">导入语句/Import Statements</a></li>
      <li><a href="#类型变量和函数声明type-variable-and-function-declarations" id="markdown-toc-类型变量和函数声明type-variable-and-function-declarations">类型，变量和函数声明/Type, Variable, and Function Declarations</a></li>
      <li><a href="#声明重载overloaded-declarations" id="markdown-toc-声明重载overloaded-declarations">声明重载/Overloaded Declarations</a></li>
      <li><a href="#扩展extensions" id="markdown-toc-扩展extensions">扩展/Extensions</a></li>
    </ul>
  </li>
  <li><a href="#常规格式general-formatting" id="markdown-toc-常规格式general-formatting">常规格式/General Formatting</a>    <ul>
      <li><a href="#单行字符限制column-limit" id="markdown-toc-单行字符限制column-limit">单行字符限制/Column Limit</a></li>
      <li><a href="#花括号braces" id="markdown-toc-花括号braces">花括号/Braces</a></li>
      <li><a href="#分号semicolons" id="markdown-toc-分号semicolons">分号/Semicolons</a></li>
      <li><a href="#每行一个语句one-statement-per-line" id="markdown-toc-每行一个语句one-statement-per-line">每行一个语句/One Statement Per Line</a></li>
      <li><a href="#换行line-wrapping" id="markdown-toc-换行line-wrapping">换行/Line-Wrapping</a>        <ul>
          <li><a href="#函数声明function-declarations" id="markdown-toc-函数声明function-declarations">函数声明/Function Declarations</a></li>
          <li><a href="#类型和拓展声明type-and-extension-declarations" id="markdown-toc-类型和拓展声明type-and-extension-declarations">类型和拓展声明/Type and Extension Declarations</a></li>
          <li><a href="#函数调用function-calls" id="markdown-toc-函数调用function-calls">函数调用/Function Calls</a></li>
          <li><a href="#控制流语句control-flow-statements" id="markdown-toc-控制流语句control-flow-statements">控制流语句/Control Flow Statements</a></li>
          <li><a href="#其他表达式other-expressions" id="markdown-toc-其他表达式other-expressions">其他表达式/Other Expressions</a></li>
        </ul>
      </li>
      <li><a href="#水平空格horizontal-whitespace" id="markdown-toc-水平空格horizontal-whitespace">水平空格/Horizontal Whitespace</a></li>
      <li><a href="#水平对齐horizontal-alignment" id="markdown-toc-水平对齐horizontal-alignment">水平对齐/Horizontal Alignment</a></li>
      <li><a href="#垂直空行vertical-whitespace" id="markdown-toc-垂直空行vertical-whitespace">垂直空行/Vertical Whitespace</a></li>
      <li><a href="#括号parentheses" id="markdown-toc-括号parentheses">括号/Parentheses</a></li>
    </ul>
  </li>
  <li><a href="#特定结构格式化formatting-specific-constructs" id="markdown-toc-特定结构格式化formatting-specific-constructs">特定结构格式化/Formatting Specific Constructs</a>    <ul>
      <li><a href="#非文档注释non-documentation-comments" id="markdown-toc-非文档注释non-documentation-comments">非文档注释/Non-Documentation Comments</a></li>
      <li><a href="#属性properties" id="markdown-toc-属性properties">属性/Properties</a></li>
      <li><a href="#switch-语句switch-statements" id="markdown-toc-switch-语句switch-statements">Switch 语句/Switch Statements</a></li>
      <li><a href="#枚举-caseenum-cases" id="markdown-toc-枚举-caseenum-cases">枚举 Case/Enum Cases</a></li>
      <li><a href="#尾随闭包trailing-closures" id="markdown-toc-尾随闭包trailing-closures">尾随闭包/Trailing Closures</a></li>
      <li><a href="#末尾逗号trailing-commas" id="markdown-toc-末尾逗号trailing-commas">末尾逗号/Trailing Commas</a></li>
      <li><a href="#数字字面量numeric-literals" id="markdown-toc-数字字面量numeric-literals">数字字面量/Numeric Literals</a></li>
      <li><a href="#注解attributes" id="markdown-toc-注解attributes">注解/Attributes</a></li>
    </ul>
  </li>
  <li><a href="#命名naming" id="markdown-toc-命名naming">命名/Naming</a>    <ul>
      <li><a href="#apple-api-代码风格指南apples-api-style-guidelines" id="markdown-toc-apple-api-代码风格指南apples-api-style-guidelines">Apple API 代码风格指南/Apple’s API Style Guidelines</a></li>
      <li><a href="#命名约定不涉及访问控制naming-conventions-are-not-access-control" id="markdown-toc-命名约定不涉及访问控制naming-conventions-are-not-access-control">命名约定不涉及访问控制/Naming Conventions Are Not Access Control</a></li>
      <li><a href="#标识符identifiers" id="markdown-toc-标识符identifiers">标识符/Identifiers</a></li>
      <li><a href="#构造器initializers" id="markdown-toc-构造器initializers">构造器/Initializers</a></li>
      <li><a href="#静态属性和类属性static-and-class-properties" id="markdown-toc-静态属性和类属性static-and-class-properties">静态属性和类属性/Static and Class Properties</a></li>
      <li><a href="#全局常量global-constants" id="markdown-toc-全局常量global-constants">全局常量/Global Constants</a></li>
      <li><a href="#代理方法delegate-methods" id="markdown-toc-代理方法delegate-methods">代理方法/Delegate Methods</a></li>
    </ul>
  </li>
  <li><a href="#编程实践programming-practices" id="markdown-toc-编程实践programming-practices">编程实践/Programming Practices</a>    <ul>
      <li><a href="#编译器警告compiler-warnings" id="markdown-toc-编译器警告compiler-warnings">编译器警告/Compiler Warnings</a></li>
      <li><a href="#构造器initializers-1" id="markdown-toc-构造器initializers-1">构造器/Initializers</a></li>
      <li><a href="#属性properties-1" id="markdown-toc-属性properties-1">属性/Properties</a></li>
      <li><a href="#类型简称types-with-shorthand-names" id="markdown-toc-类型简称types-with-shorthand-names">类型简称/Types with Shorthand Names</a></li>
      <li><a href="#可选类型optional-types" id="markdown-toc-可选类型optional-types">可选类型/Optional Types</a></li>
      <li><a href="#错误类型error-types" id="markdown-toc-错误类型error-types">错误类型/Error Types</a></li>
      <li><a href="#强制解包和强制擦除force-unwrapping-and-force-casts" id="markdown-toc-强制解包和强制擦除force-unwrapping-and-force-casts">强制解包和强制擦除/Force Unwrapping and Force Casts</a></li>
      <li><a href="#可选值隐式解包implicitly-unwrapped-optionals" id="markdown-toc-可选值隐式解包implicitly-unwrapped-optionals">可选值隐式解包/Implicitly Unwrapped Optionals</a></li>
      <li><a href="#访问等级access-levels" id="markdown-toc-访问等级access-levels">访问等级/Access Levels</a></li>
      <li><a href="#嵌套和命名空间nesting-and-namespacing" id="markdown-toc-嵌套和命名空间nesting-and-namespacing">嵌套和命名空间/Nesting and Namespacing</a></li>
      <li><a href="#提前退出的-guardguards-for-early-exits" id="markdown-toc-提前退出的-guardguards-for-early-exits">提前退出的 <code class="highlighter-rouge">guard</code>/<code class="highlighter-rouge">guard</code>s for Early Exits</a></li>
      <li><a href="#for-where-循环for-where-loops" id="markdown-toc-for-where-循环for-where-loops"><code class="highlighter-rouge">for</code>-<code class="highlighter-rouge">where</code> 循环/<code class="highlighter-rouge">for</code>-<code class="highlighter-rouge">where</code> Loops</a></li>
      <li><a href="#在-switch-语句里的-fallthrough-fallthrough-in-switch-statements" id="markdown-toc-在-switch-语句里的-fallthrough-fallthrough-in-switch-statements">在 <code class="highlighter-rouge">switch</code> 语句里的 <code class="highlighter-rouge">fallthrough</code>/ <code class="highlighter-rouge">fallthrough</code> in <code class="highlighter-rouge">switch</code> Statements</a></li>
      <li><a href="#模式匹配pattern-matching" id="markdown-toc-模式匹配pattern-matching">模式匹配/Pattern Matching</a></li>
      <li><a href="#元组模式tuple-patterns" id="markdown-toc-元组模式tuple-patterns">元组模式/Tuple Patterns</a></li>
      <li><a href="#数字和字符串字面量numeric-and-string-literals" id="markdown-toc-数字和字符串字面量numeric-and-string-literals">数字和字符串字面量/Numeric and String Literals</a></li>
      <li><a href="#playground-字面量playground-literals" id="markdown-toc-playground-字面量playground-literals">Playground 字面量/Playground Literals</a></li>
      <li><a href="#捕获溢出运算trapping-vs-overflowing-arithmetic" id="markdown-toc-捕获溢出运算trapping-vs-overflowing-arithmetic">捕获溢出运算/Trapping vs. Overflowing Arithmetic</a></li>
      <li><a href="#定义新运算符defining-new-operators" id="markdown-toc-定义新运算符defining-new-operators">定义新运算符/Defining New Operators</a></li>
      <li><a href="#重载已存在运算符overloading-existing-operators" id="markdown-toc-重载已存在运算符overloading-existing-operators">重载已存在运算符/Overloading Existing Operators</a></li>
    </ul>
  </li>
  <li><a href="#文档注释documentation-comments" id="markdown-toc-文档注释documentation-comments">文档注释/Documentation Comments</a>    <ul>
      <li><a href="#通常格式general-format" id="markdown-toc-通常格式general-format">通常格式/General Format</a></li>
      <li><a href="#一句话概括single-sentence-summary" id="markdown-toc-一句话概括single-sentence-summary">一句话概括/Single-Sentence Summary</a></li>
      <li><a href="#形参返回值和抛出标签parameter-returns-and-throws-tags" id="markdown-toc-形参返回值和抛出标签parameter-returns-and-throws-tags">形参，返回值和抛出标签/Parameter, Returns, and Throws Tags</a></li>
      <li><a href="#apple-标记格式apples-markup-format" id="markdown-toc-apple-标记格式apples-markup-format">Apple 标记格式/Apple’s Markup Format</a></li>
      <li><a href="#注释的位置where-to-document" id="markdown-toc-注释的位置where-to-document">注释的位置/Where to Document</a></li>
    </ul>
  </li>
</ul>
<h2 id="源文件基础source-file-basics">源文件基础/Source File Basics</h2>

<h3 id="文件名file-names">文件名/File Names</h3>

<p>All Swift source files end with the extension <code class="highlighter-rouge">.swift</code>.</p>

<p>所有 Swift 源文件以扩展名 <code class="highlighter-rouge">.swift</code> 结尾。</p>

<p>In general, the name of a source file best describes the primary entity that it
contains. A file that primarily contains a single type has the name of that
type. A file that extends an existing type with protocol conformance is named
with a combination of the type name and the protocol name, joined with a plus
(<code class="highlighter-rouge">+</code>) sign. For more complex situations, exercise your best judgment.</p>

<p>通常来说，源文件的名字最好描述的是包含的主要内容。文件主要包含单个类型则命名为该类型名字。文件包含为已存在类型添加协议遵循的拓展则命名为类名和协议名的组合，通过加号（+）连接。对于更复杂的情况，最好由你自己判断。</p>

<p>For example,</p>

<p>例如，</p>

<ul>
  <li>A file containing a single type <code class="highlighter-rouge">MyType</code> is named <code class="highlighter-rouge">MyType.swift</code>.</li>
  <li>文件中包含单个类型 <code class="highlighter-rouge">MyType</code> ，命名为 <code class="highlighter-rouge">MyType.swift</code>。</li>
  <li>A file containing a type <code class="highlighter-rouge">MyType</code> and some top-level helper functions is also
named <code class="highlighter-rouge">MyType.swift</code>. (The top-level helpers are not the primary entity.)</li>
  <li>文件中包含类型 <code class="highlighter-rouge">MyType</code> 和一些顶层的工具函数，也命名为 <code class="highlighter-rouge">MyType.swift</code>。（顶层的工具函数不是主要的内容。）</li>
  <li>A file containing a single extension to a type <code class="highlighter-rouge">MyType</code> that adds conformance
to a protocol <code class="highlighter-rouge">MyProtocol</code> is named <code class="highlighter-rouge">MyType+MyProtocol.swift</code>.</li>
  <li>文件中包含单个为类型 <code class="highlighter-rouge">MyType</code> 添加 <code class="highlighter-rouge">MyProtocol</code> 协议遵循的拓展，命名为 <code class="highlighter-rouge">MyType+MyProtocol.swift</code>。</li>
  <li>A file containing multiple extensions to a type <code class="highlighter-rouge">MyType</code> that add
conformances, nested types, or other functionality to a type can be named more
generally, as long as it is prefixed with <code class="highlighter-rouge">MyType+</code>; for example,
<code class="highlighter-rouge">MyType+Additions.swift</code>.</li>
  <li>文件中包含多个为类型 <code class="highlighter-rouge">MyType</code> 添加协议遵循，嵌套类型或者其他功能的拓展，可以命名得更通用化，只要它的前缀是 <code class="highlighter-rouge">MyType+</code>；例如，<code class="highlighter-rouge">MyType+Additions.swift</code>。</li>
  <li>A file containing related declarations that are not otherwise scoped under a
common type or namespace (such as a collection of global mathematical
functions) can be named descriptively; for example, <code class="highlighter-rouge">Math.swift</code>.</li>
  <li>文件中包含多个在公共类型或命名空间下没有作用域限制的相关声明（比如一系列全局的数学函数），可以命名得更有描述性。例如：<code class="highlighter-rouge">Math.swift</code>。</li>
</ul>

<h3 id="文件编码file-encoding">文件编码/File Encoding</h3>

<p>Source files are encoded in UTF-8.</p>

<p>源文件以 UTF-8 方式编码。</p>

<h3 id="空白符whitespace-characters">空白符/Whitespace Characters</h3>

<p>Aside from the line terminator, the Unicode horizontal space character
(<code class="highlighter-rouge">U+0020</code>) is the only whitespace character that appears anywhere in a source
file. The implications are:</p>

<p>除了行终止符之外，Unicode 水平空格符（<code class="highlighter-rouge">U+0020</code>）是唯一可以出现在源文件里的空白符。这意味着：</p>

<ul>
  <li>All other whitespace characters in string and character literals are
represented by their corresponding escape sequence.</li>
  <li>所有其他在字符串或者字符字面量里的空白符都要用对应的转义字符表示。</li>
  <li>Tab characters are not used for indentation.</li>
  <li>制表符不用于缩进。</li>
</ul>

<h3 id="特殊转义字符special-escape-sequences">特殊转义字符/Special Escape Sequences</h3>

<p>For any character that has a special escape sequence (<code class="highlighter-rouge">\t</code>, <code class="highlighter-rouge">\n</code>, <code class="highlighter-rouge">\r</code>, <code class="highlighter-rouge">\"</code>,
<code class="highlighter-rouge">\'</code>, <code class="highlighter-rouge">\\</code>, and <code class="highlighter-rouge">\0</code>), that sequence is used rather than the equivalent Unicode
(e.g., <code class="highlighter-rouge">\u{000a}</code>) escape sequence.</p>

<p>任何字符中如果包含了特殊转义字符（<code class="highlighter-rouge">\t</code>, <code class="highlighter-rouge">\n</code>, <code class="highlighter-rouge">\r</code>, <code class="highlighter-rouge">\"</code>, <code class="highlighter-rouge">\'</code>, <code class="highlighter-rouge">\\</code> 和 <code class="highlighter-rouge">\0</code>），该转义字符会被直接使用，而不会是其等价的 Unicode 转义字符（例如：<code class="highlighter-rouge">\u{000a}</code>）。</p>

<h3 id="不可见字符和修饰符invisible-characters-and-modifiers">不可见字符和修饰符/Invisible Characters and Modifiers</h3>

<p>Invisible characters, such as the zero width space and other control characters
that do not affect the graphical representation of a string, are always written
as Unicode escape sequences.</p>

<p>不可见字符，例如零宽空格和其他在字符串里不影响可视化表达的控制字符，都要用 Unicode 转义字符表示。</p>

<p>Control characters, combining characters, and variation selectors that <em>do</em>
affect the graphical representation of a string are not escaped when they are
attached to a character or characters that they modify. If such a Unicode scalar
is present in isolation or is otherwise not modifying another character in the
same string, it is written as a Unicode escape sequence.</p>

<p>控制字符，组合字符，以及字符串里<em>会</em>影响可视化表达的异体字选择器当跟在其修改的字符后面则不转义。如果该 Unicode 标量单独使用或者没有修改同字符串中其他的字符，则用 Unicode 转义字符表示。</p>

<p>The strings below are well-formed because the umlauts and variation selectors
associate with neighboring characters in the string. The second example is in
fact composed of <em>five</em> Unicode scalars, but they are unescaped because the
specific combination is rendered as a single character.</p>

<p>下面的字符串是符合要求的，因为元音和异体字选择器都和临近的字符关联。第二个例子实际上由 <em>5</em> 个 Unicode 标量组成，不过它们没有被转义，因为在特定组合后作为单一字符进行渲染。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">size</span> <span class="o">=</span> <span class="s">"Übergröße"</span>
<span class="k">let</span> <span class="nv">shrug</span> <span class="o">=</span> <span class="s">"🤷🏿‍️"</span>
</code></pre></div></div>

<p>In the example below, the umlaut and variation selector are in strings by
themselves, so they are escaped.</p>

<p>下面的例子中，字符串里元音和异体字选择器只有它们自身，所以要被转义。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">diaeresis</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{0308}</span><span class="s">"</span>
<span class="k">let</span> <span class="nv">skinToneType6</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{1F3FF}</span><span class="s">"</span>
</code></pre></div></div>

<p>If the umlaut were included in the string literally, it would combine with
the preceding quotation mark, impairing readability. Likewise, while most
systems may render a standalone skin tone modifier as a block graphic, the
example below is still forbidden because it is a modifier that is not modifying
a character in the same string.</p>

<p>如果元音以字面量方式出现在字符串里，它会和前面的引号组合起来，影响可读性。同样的，尽管大部分系统会将单独的皮肤着色修饰符作为单独图形块渲染，但下面例子依旧是不允许的，因为该修饰符并没有修改同一字符串里任何字符。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">diaeresis</span> <span class="o">=</span> <span class="s">"̈"</span>
<span class="k">let</span> <span class="nv">skinToneType6</span> <span class="o">=</span> <span class="s">"🏿"</span>
</code></pre></div></div>

<h3 id="字符串字面量string-literals">字符串字面量/String Literals</h3>

<p>Unicode escape sequences (<code class="highlighter-rouge">\u{????}</code>) and literal code points (for example, <code class="highlighter-rouge">Ü</code>)
outside the 7-bit ASCII range are never mixed in the same string.</p>

<p>7 位 ASCII 码范围以外的 Unicode 转义字符（<code class="highlighter-rouge">\u{????}</code>）和代码点字面量（例如：<code class="highlighter-rouge">Ü</code>）永远不要在同一字符串里混合使用。</p>

<p>More specifically, string literals are either:</p>

<p>更具体来说，字符串字面量只能是下面两者之一:</p>

<ul>
  <li>composed of a combination of Unicode code points written literally and/or
single character escape sequences (such as <code class="highlighter-rouge">\t</code>, but <em>not</em> <code class="highlighter-rouge">\u{????}</code>), or</li>
  <li>由字面量方式的 Unicode 代码点组合和/或单一转义字符组合，或者</li>
  <li>composed of 7-bit ASCII with any number of Unicode escape sequences and/or
other escape sequences.</li>
  <li>由任意数量的 Unicode 转义字符的 7 位 ASCII 码和或其他转义字符组成。</li>
</ul>

<p>The following example is correct because <code class="highlighter-rouge">\n</code> is allowed to be present among
other Unicode code points.</p>

<p>下面的例子是正确的，因为 <code class="highlighter-rouge">\n</code> 允许在其他 Unicode 代码点中存在。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">size</span> <span class="o">=</span> <span class="s">"Übergröße</span><span class="se">\n</span><span class="s">"</span>
</code></pre></div></div>

<p>The following example is allowed because it follows the rules above, but it is
<em>not preferred</em> because the text is harder to read and understand compared to
the string above.</p>

<p>下面的例子也是被允许的，因为它遵守了上面的规则，但它并不是 <code class="highlighter-rouge">最优选</code>，因为和上面的字符串相比，它更难以阅读和理解。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">size</span> <span class="o">=</span> <span class="s">"</span><span class="se">\u{00DC}</span><span class="s">bergr</span><span class="se">\u{00F6}\u{00DF}</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span>
</code></pre></div></div>

<p>The example below is forbidden because it mixes code points outside the 7-bit
ASCII range in both literal form and in escaped form.</p>

<p>下面的例子是被禁止的，因为它混合了 7 位 ASCII 码范围以外的字面量形式和转义形式的代码点。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">size</span> <span class="o">=</span> <span class="s">"Übergr</span><span class="se">\u{00F6}\u{00DF}</span><span class="s">e</span><span class="se">\n</span><span class="s">"</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Aside:</strong> Never make your code less readable simply out of fear
that some programs might not handle non-ASCII characters properly. If that
should happen, those programs are broken and must be fixed.</p>

  <p><strong>题外话</strong>：永远别因为担心某些程序可能无法正确处理非 ASCII 码字符而降低代码的可读性。如果发生了，那些程序是无法被使用的，而且应该被修复。</p>
</blockquote>

<h2 id="源文件结构source-file-structure">源文件结构/Source File Structure</h2>

<h3 id="文件注释file-comments">文件注释/File Comments</h3>

<p>Comments describing the contents of a source file are optional. They are
discouraged for files that contain only a single abstraction (such as a class
declaration)—in those cases, the documentation comment on the abstraction
itself is sufficient and a file comment is only present if it provides
additional useful information. File comments are allowed for files that contain
multiple abstractions in order to document that grouping as a whole.</p>

<p>描述源文件内容的注释是可选的。对只包含了单一抽象（例如一个类的声明）的文件并不建议用这种注释 — 这种情况下，抽象本身的文档注释就足够了，文件注释只有当提供了额外的有用信息时才需要。文件注释在文件中包含多个抽象时是允许的，为了对完整的分组进行注释。</p>

<h3 id="导入语句import-statements">导入语句/Import Statements</h3>

<p>A source file imports exactly the top-level modules that it needs; nothing more
and nothing less. If a source file uses definitions from both <code class="highlighter-rouge">UIKit</code> and
<code class="highlighter-rouge">Foundation</code>, it imports both explicitly; it does not rely on the fact that some
Apple frameworks transitively import others as an implementation detail.</p>

<p>源文件中应该显式导入需要的顶层模块；不要多也不要少。如果源文件中同时使用了 <code class="highlighter-rouge">UIKit</code> 中的定义和 <code class="highlighter-rouge">Foundation</code> 中的定义，那么都进行显式导入；这和有些 Apple 框架已经在实现细节中导入其他框架并不冲突。</p>

<p>Imports of whole modules are preferred to imports of individual declarations or
submodules.</p>

<p>优先考虑导入整个模块而非导入单个声明或者子模块。</p>

<blockquote>
  <p>There are a number of reasons to avoid importing individual members:</p>

  <p>避免导入单个成员的原因如下：</p>

  <ul>
    <li>There is no automated tooling to resolve/organize imports.</li>
    <li>没有自动化工具来解决/组织那些导入。</li>
    <li>Existing automated tooling (such as Xcode’s migrator) are less likely to
work well on code that imports individual members because they are
considered corner cases.</li>
    <li>现存地自动化工具（例如 Xcode 迁移器）不能很好地工作在导入单个成员的代码里，因为它们是边界情况。</li>
    <li>The prevailing style in Swift (based on official examples and community
code) is to import entire modules.</li>
    <li>目前流行的 Swift 代码风格（基于官方例子和社区代码）都是导入整个模块的。</li>
  </ul>
</blockquote>

<p>Imports of individual declarations are permitted when importing the whole module
would otherwise pollute the global namespace with top-level definitions (such as
C interfaces). Use your best judgment in these situations.</p>

<p>当导入完整模块的顶层定义（例如 C 接口）会污染全局命名空间时，导入单个声明是允许的。在这些情况下，由你自己判断。</p>

<p>Imports of submodules are permitted if the submodule exports functionality that
is not available when importing the top-level module. For example,
<code class="highlighter-rouge">UIKit.UIGestureRecognizerSubclass</code> must be imported explicitly to expose the
methods that allow client code to subclass <code class="highlighter-rouge">UIGestureRecognizer</code>—those are
not visible by importing <code class="highlighter-rouge">UIKit</code> alone.</p>

<p>如果子模块的导出功能在只导入顶层模块时不可用，那么允许导入子模块。例如：<code class="highlighter-rouge">UIKit.UIGestureRecognizerSubclass</code> 必须要显式导入，以暴露继承 <code class="highlighter-rouge">UIGestureRecognizer</code> 时代码允许重写的方法  - 这在只导入 <code class="highlighter-rouge">UIKit</code> 时并不可见。</p>

<p>Import statements are not line-wrapped.</p>

<p>导入语句不可换行。</p>

<p>Import statements are the first non-comment tokens in a source file. They are
grouped in the following fashion, with the imports in each group ordered
lexicographically and with exactly one blank line between each group:</p>

<p>导入语句放在除了注释以外的最前面。按以下方式分组，每组中的导入按照字母顺序排序，每组之间只有一个空行：</p>

<ol>
  <li>
    <p>Module/submodule imports not under test</p>

    <p>无测试模块/子模块的导入</p>
  </li>
  <li>
    <p>Individual declaration imports (<code class="highlighter-rouge">class</code>, <code class="highlighter-rouge">enum</code>, <code class="highlighter-rouge">func</code>, <code class="highlighter-rouge">struct</code>, <code class="highlighter-rouge">var</code>)</p>

    <p>单个声明的导入 (<code class="highlighter-rouge">class</code>, <code class="highlighter-rouge">enum</code>, <code class="highlighter-rouge">func</code>, <code class="highlighter-rouge">struct</code>, <code class="highlighter-rouge">var</code>)</p>
  </li>
  <li>
    <p>Modules imported with <code class="highlighter-rouge">@testable</code> (only present in test sources)</p>

    <p><code class="highlighter-rouge">@testable</code> 模块的导入（只存在测试源码中）</p>
  </li>
</ol>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">import</span> <span class="kt">CoreLocation</span>
<span class="kd">import</span> <span class="kt">MyThirdPartyModule</span>
<span class="kd">import</span> <span class="kt">SpriteKit</span>
<span class="kd">import</span> <span class="kt">UIKit</span>

<span class="kd">import</span> <span class="kd">func</span> <span class="kt">Darwin</span><span class="o">.</span><span class="kt">C</span><span class="o">.</span><span class="n">isatty</span>

<span class="kd">@testable</span> <span class="kd">import</span> <span class="kt">MyModuleUnderTest</span>
</code></pre></div></div>

<h3 id="类型变量和函数声明type-variable-and-function-declarations">类型，变量和函数声明/Type, Variable, and Function Declarations</h3>

<p>In general, most source files contain only one top-level type, especially when
the type declaration is large. Exceptions are allowed when it makes sense to
include multiple related types in a single file. For example,</p>

<p>通常情况下，大部分源文件只包含一个顶层类型，特别是当类型声明很庞大时。除非在同一文件里包含多个相关类型是有意义的。例如，</p>

<ul>
  <li>
    <p>A class and its delegate protocol may be defined in the same file.</p>
  </li>
  <li>
    <p>类和它的代理协议可以定义在同一文件中。</p>
  </li>
  <li>
    <p>A type and its small related helper types may be defined in the same file.
This can be useful when using <code class="highlighter-rouge">fileprivate</code> to restrict certain functionality
of the type and/or its helpers to only that file and not the rest of the
module.</p>
  </li>
  <li>
    <p>类型和它相关的轻量帮助类型可以定义在同一文件中。这种时候</p>

    <p><code class="highlighter-rouge">fileprivate</code> 是很有用的，可以将类型和/或它帮助类的某些功能限制在那个文件中而非暴露给模块的其他地方。</p>
  </li>
</ul>

<p>The order of types, variables, and functions in a source file, and the order of
the members of those types, can have a great effect on readability. However,
there is no single correct recipe for how to do it; different files and
different types may order their contents in different ways.</p>

<p>在源文件中类型，变量和函数之间的顺序，和该类型成员的顺序，都会大大影响可读性。然而，如何组织它们并没有单一正确的法则；不同的文件和不同的类型可以用不同的方式组织它们内容的排序。</p>

<p>What is important is that each file and type uses <em><strong>some</strong> logical order,</em>
which its maintainer could explain if asked. For example, new methods are not
just habitually added to the end of the type, as that would yield “chronological
by date added” ordering, which is not a logical ordering.</p>

<p>而重要的是，每一个文件和类型使用_<strong>同一</strong>排序逻辑_，以便维护者在被询问时可以解释清楚。例如，新的方法不能习惯性地加在类型的最后面，因为这只是顺从“日期递增地时间排序”，而不是有逻辑性的排序。</p>

<p>When deciding on the logical order of members, it can be helpful for readers and
future writers (including yourself) to use <code class="highlighter-rouge">// MARK:</code> comments to provide
descriptions for that grouping. These comments are also interpreted by Xcode and
provide bookmarks in the source window’s navigation bar. (Likewise,
<code class="highlighter-rouge">// MARK: - </code>, written with a hyphen before the description, causes Xcode to
insert a divider before the menu item.) For example,</p>

<p>当决定成员的排序逻辑后，使用 <code class="highlighter-rouge">// MARK:</code> 注释对该分组提供描述，对阅读者和将来的编码者（包括你自己）是很有帮助的。这种注释也会被 Xcode 理解并在源码窗口的导航栏中提供书签。（类似的还有 <code class="highlighter-rouge">// MARK: -</code>，在描述之前使用一个连字符的话， Xcode 会在菜单元素前插入一条分隔线。）例如，</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">MovieRatingViewController</span><span class="p">:</span> <span class="kt">UITableViewController</span> <span class="p">{</span>

  <span class="c1">// MARK: - View controller lifecycle methods</span>

  <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewWillAppear</span><span class="p">(</span><span class="n">_</span> <span class="nv">animated</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="c1">// MARK: - Movie rating manipulation methods</span>

  <span class="kd">@objc</span> <span class="kd">private</span> <span class="kd">func</span> <span class="nf">ratingStarWasTapped</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">?)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="kd">@objc</span> <span class="kd">private</span> <span class="kd">func</span> <span class="nf">criticReviewWasTapped</span><span class="p">(</span><span class="n">_</span> <span class="nv">sender</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">?)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="声明重载overloaded-declarations">声明重载/Overloaded Declarations</h3>

<p>When a type has multiple initializers or subscripts, or a file/type has multiple
functions with the same base name (though perhaps with different argument
labels), <em>and</em> when these overloads appear in the same type or extension scope,
they appear sequentially with no other code in between.</p>

<p>当一个类型有多个构造器或者下标，或者一个文件/类型内有多个相同名字的函数（尽管可能有不同的实参标签），<em>并且</em>当这些重载在同一类型或者扩展作用域内时，它们应该按顺序排列，不应该在中间插入其他代码。</p>

<h3 id="扩展extensions">扩展/Extensions</h3>

<p>Extensions can be used to organize functionality of a type across multiple
“units.” As with member order, the organizational structure/grouping you choose
can have a great effect on readability; you must use <em><strong>some</strong> logical
organizational structure</em> that you could explain to a reviewer if asked.</p>

<p>扩展可以将一个类型的功能组织到多个“单元”中。配合成员排序和所选择的组织结构/分组会对代码可读性有很大的帮助；你必须使用_<strong>某种</strong>_能给审查者解释的_逻辑结构_进行组织。</p>

<h2 id="常规格式general-formatting">常规格式/General Formatting</h2>

<h3 id="单行字符限制column-limit">单行字符限制/Column Limit</h3>

<p>Swift code has a column limit of 100 characters. Except as noted below, any line
that would exceed this limit must be line-wrapped as described in
<a href="#line-wrapping">Line-Wrapping</a>.</p>

<p>Swift 代码有 100 字符单行限制。除了下面的说明之外，任何超过该限制的行都需要换行，详情见 <a href="#line-wrapping">换行</a>。</p>

<p><strong>Exceptions:</strong></p>

<p><strong>例外：</strong></p>

<ol>
  <li>
    <p>Lines where obeying the column limit is not possible without breaking a
meaningful unit of text that should not be broken (for example, a long URL in
a comment).</p>

    <p>即便是遵循单行字符限制的行也不应该破坏文本中有意义的部分（例如，注释里的长 URL ）。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">import</code> statements.</p>

    <p><code class="highlighter-rouge">import</code> 语句。</p>
  </li>
  <li>
    <p>Code generated by another tool.</p>

    <p>其他工具生成的代码。</p>
  </li>
</ol>

<h3 id="花括号braces">花括号/Braces</h3>

<p>In general, braces follow Kernighan and Ritchie (K&amp;R) style for non-empty
blocks with exceptions for Swift-specific constructs and rules:</p>

<p>通常来说，非空块的花括号遵循 Kernighan 和 Ritchie（K&amp;R）代码风格，除了 Swift 特殊结构和规则以外：</p>

<ul>
  <li>
    <p>There <strong>is no</strong> line break before the opening brace (<code class="highlighter-rouge">{</code>), <strong>unless</strong> required
by application of the rules in <a href="#line-wrapping">Line-Wrapping</a>.</p>
  </li>
  <li>
    <p>在开边花括号（<code class="highlighter-rouge">{</code>）之前<strong>不需要</strong>换行，<strong>除非</strong>是因为应用了 <a href="#line-wrapping">换行</a> 规则。</p>
  </li>
  <li>
    <p>There <strong>is a</strong> line break after the opening brace (<code class="highlighter-rouge">{</code>), except</p>
  </li>
  <li>
    <p>在开边花括号（<code class="highlighter-rouge">{</code>）之后<strong>需要</strong>换行，除了</p>

    <ul>
      <li>
        <p>in closures, where the signature of the closure is placed on the same line
as the curly brace, if it fits, and a line break follows the <code class="highlighter-rouge">in</code> keyword.</p>
      </li>
      <li>
        <p>在闭包中，闭包的签名和花括号在同一行的情况下，如果合适，在 <code class="highlighter-rouge">in</code> 关键字后面换行。</p>
      </li>
      <li>
        <p>where it may be omitted as described in
<a href="#one-statement-per-line">One Statement Per Line</a>.</p>
      </li>
      <li>
        <p>当可以省略成 <a href="#one-statement-per-line">单行语句</a>。</p>
      </li>
      <li>
        <p>empty blocks may be written as <code class="highlighter-rouge">{}</code>.</p>
      </li>
      <li>
        <p>空白块应该写作 <code class="highlighter-rouge">{}</code>。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>There <strong>is a</strong> line break before the closing brace (<code class="highlighter-rouge">}</code>), except where it may
be omitted as described in <a href="#one-statement-per-line">One Statement Per Line</a>,
or it completes an empty block.</p>
  </li>
  <li>
    <p>在闭边花括号（<code class="highlighter-rouge">}</code>）之前<strong>需要</strong>换行，除了可以省略成 <a href="#one-statement-per-line">单行语句</a> 或用在空白块的情况。</p>
  </li>
  <li>
    <p>There <strong>is a</strong> line break after the closing brace (<code class="highlighter-rouge">}</code>), <strong>if and only if</strong>
that brace terminates a statement or the body of a declaration. For example,
an <code class="highlighter-rouge">else</code> block is written <code class="highlighter-rouge">} else {</code> with both braces on the same line.</p>
  </li>
  <li>
    <p>闭边花括号（<code class="highlighter-rouge">}</code>）之后<strong>需要</strong>换行的情况，<strong>有且仅当</strong>该花括号用作终止语句或者作为声明体。例如，<code class="highlighter-rouge">else</code> 块写成 <code class="highlighter-rouge">} else {</code> 时两个花括号在同一行。</p>
  </li>
</ul>

<h3 id="分号semicolons">分号/Semicolons</h3>

<p>Semicolons (<code class="highlighter-rouge">;</code>) are <strong>not used</strong>, either to terminate or separate statements.</p>

<p>分号（<code class="highlighter-rouge">;</code>）<strong>禁止使用</strong>，无论是用于终止或者分割语句。</p>

<p>In other words, the only location where a semicolon may appear is inside a
string literal or a comment.</p>

<p>换而言之，分号只可能出现在字符串字面量或者注释中。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">printSum</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">printSum</span><span class="p">(</span><span class="n">_</span> <span class="nv">a</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  <span class="nf">print</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="每行一个语句one-statement-per-line">每行一个语句/One Statement Per Line</h3>

<p>There is <strong>at most</strong> one statement per line, and each statement is followed by a
line break, except when the line ends with a block that also contains zero
or one statements.</p>

<p>每行<strong>最多</strong>一个语句，每个语句后换行，除非该行以只包含了 0 或 1 个语句的块结尾。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">value</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">}</span>

<span class="k">defer</span> <span class="p">{</span> <span class="n">file</span><span class="o">.</span><span class="nf">close</span><span class="p">()</span> <span class="p">}</span>

<span class="k">switch</span> <span class="n">someEnum</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">first</span><span class="p">:</span> <span class="k">return</span> <span class="mi">5</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">second</span><span class="p">:</span> <span class="k">return</span> <span class="mi">10</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">third</span><span class="p">:</span> <span class="k">return</span> <span class="mi">20</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">squares</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span>

<span class="k">var</span> <span class="nv">someProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">otherObject</span><span class="o">.</span><span class="n">property</span> <span class="p">}</span>
  <span class="k">set</span> <span class="p">{</span> <span class="n">otherObject</span><span class="o">.</span><span class="n">property</span> <span class="o">=</span> <span class="n">newValue</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">var</span> <span class="nv">someProperty</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">otherObject</span><span class="o">.</span><span class="nf">somethingElse</span><span class="p">()</span> <span class="p">}</span>

<span class="kd">required</span> <span class="nf">init</span><span class="p">?(</span><span class="n">coder</span> <span class="nv">aDecoder</span><span class="p">:</span> <span class="kt">NSCoder</span><span class="p">)</span> <span class="p">{</span> <span class="nf">fatalError</span><span class="p">(</span><span class="s">"no coder"</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>Wrapping the body of a single-statement block onto its own line is always
allowed. Exercise best judgment when deciding whether to place a conditional
statement and its body on the same line. For example, single line conditionals
work well for early-return and basic cleanup tasks, but less so when the body
contains a function call with significant logic. When in doubt, write it as a
multi-line statement.</p>

<p>将块里包含的单个语句和块放在同一行总是允许的。由你自己判断是否将条件语句和它的执行体放在同一行中。例如，单行条件适合跟提前返回并进行简单收尾的代码放在一行，但是当执行体里包含了函数调用或者重要的逻辑就不太合适了。一旦纠结，使用多行语句。</p>

<h3 id="换行line-wrapping">换行/Line-Wrapping</h3>

<blockquote>
  <p>Terminology note: <strong>Line-wrapping</strong> is the activity of dividing code into
multiple lines that might otherwise legally occupy a single line.</p>

  <p>术语说明：<strong>换行</strong>是将代码分割到多个行的行为，否则它们都会堆积到同一行。</p>
</blockquote>

<p>For the purposes of Google Swift style, many declarations (such as type
declarations and function declarations) and other expressions (like function
calls) can be partitioned into <strong>breakable</strong> units that are separated by
<strong>unbreakable</strong> delimiting token sequences.</p>

<p>根据 Google Swift 代码风格的思想，大多声明（例如类型声明和函数声明）和其他表达式（例如函数调用）可以被划分成<strong>可破坏</strong>单元，被定义的<strong>不可破坏</strong>标记符进行分割。</p>

<p>As an example, consider the following complex function declaration, which needs
to be line-wrapped:</p>

<p>举个例子，考虑下面这个复杂的函数声明该如何进行换行：</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span><span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span> <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This declaration is split as follows (scroll horizontally if necessary to see
the full example). Unbreakable token sequences are indicated in orange;
breakable sequences are indicated in blue.</p>

<p>这个声明可以像下面这样进行分割（要看完整例子可能需要水平滑动）。不可破坏标记符标记为橙色；可破坏符号标记为蓝色。</p>

<pre class="lw-container lw-container-numbered">
<span class="lw-ub">public func index&lt;</span><span class="lw-br">Elements: Collection, Element</span><span class="lw-ub">&gt;(</span><span class="lw-br">of element: Element, in collection: Elements</span><span class="lw-ub">) -&gt;</span><span class="lw-br">Elements.Index?</span><span class="lw-ub">where</span><span class="lw-br">Elements.Element == Element, Element: Equatable</span>{
  // ...
}
</pre>

<ol>
  <li>
    <p>The <strong>unbreakable</strong> token sequence up through the open angle bracket (<code class="highlighter-rouge">&lt;</code>)
that begins the generic argument list.</p>

    <p><strong>不可破坏</strong>标记符从开始直到标志范型实参列表开始的开边尖括号（<code class="highlighter-rouge">&lt;</code>）。</p>
  </li>
  <li>
    <p>The <strong>breakable</strong> list of generic arguments.</p>

    <p>范型实参的<strong>可破坏</strong>列表。</p>
  </li>
  <li>
    <p>The <strong>unbreakable</strong> token sequence (<code class="highlighter-rouge">&gt;(</code>) that separates the generic
arguments from the formal arguments.</p>

    <p><strong>不可破坏</strong>标记符（<code class="highlighter-rouge">&gt;（</code>）将范型实参和正式实参进行分割。</p>
  </li>
  <li>
    <p>The <strong>breakable</strong> comma-delimited list of formal arguments.</p>

    <p>正式实参的<strong>可破坏</strong>逗号分隔列表。</p>
  </li>
  <li>
    <p>The <strong>unbreakable</strong> token-sequence from the closing parenthesis (<code class="highlighter-rouge">)</code>) up
through the arrow (<code class="highlighter-rouge">-&gt;</code>) that precedes the return type.</p>

    <p><strong>不可破坏</strong>标记符从闭边括号（<code class="highlighter-rouge">)</code>）到返回类型之前的箭头（<code class="highlighter-rouge">-&gt;</code>）。</p>
  </li>
  <li>
    <p>The <strong>breakable</strong> return type.</p>

    <p><strong>可破坏</strong>返回类型。</p>
  </li>
  <li>
    <p>The <strong>unbreakable</strong> <code class="highlighter-rouge">where</code> keyword that begins the generic constraints list.</p>

    <p>在范型约束列表开始的<strong>不可破坏</strong> <code class="highlighter-rouge">where</code> 关键字。</p>
  </li>
  <li>
    <p>The <strong>breakable</strong> comma-delimited list of generic constraints.</p>

    <p>范型约束的<strong>可破坏</strong>逗号分隔列表。</p>
  </li>
</ol>

<p>Using these concepts, the cardinal rules of Google Swift style for line-wrapping
are:</p>

<p>用上这些概念，Google Swift 代码风格的基本换行规则如下：</p>

<ol>
  <li>
    <p>If the entire declaration, statement, or expression fits on one line, then do
that.</p>

    <p>如果整个声明，语句或者表达式适合使用一行，就使用一行。</p>
  </li>
  <li>
    <p>Comma-delimited lists are only laid out in one direction: horizontally or
vertically. In other words, all elements must fit on the same line, or each
element must be on its own line. A horizontally-oriented list does not
contain any line breaks, even before the first element or after the last
element. Except in control flow statements, a vertically-oriented list
contains a line break before the first element and after each element.</p>

    <p>逗号分隔列表只能一个方向展示：水平或者垂直。换句话说，所有元素必须在同一行上，或者每个元素必须在单独的行上。水平向的列表不包含任何换行，即使在第一个元素之前或者最后一个元素之后。除控制流语句外，垂直向的列表在第一个元素之前和每个元素之后需要换行。</p>
  </li>
  <li>
    <p>A continuation line starting with an unbreakable token sequence is indented
at the same level as the original line.</p>

    <p>以不可破坏标记符开始的后续行和原始行缩进保持一致。</p>
  </li>
  <li>
    <p>A continuation line that is part of a vertically-oriented comma-delimited
list is indented exactly +2 from the original line.</p>

    <p>作为垂直向逗号分隔列表一部分的后续行在原始行缩进的基础上+2。</p>
  </li>
  <li>
    <p>When an open curly brace (<code class="highlighter-rouge">{</code>) follows a line-wrapped declaration or
expression, it is on the same line as the final continuation line unless that
line is indented at +2 from the original line. In that case, the brace is
placed on its own line, to avoid the continuation lines from blending
visually with the body of the subsequent block.</p>

    <p>在换行的声明或者表达式后的开边花括号（<code class="highlighter-rouge">{</code>），除非该行的缩进是在原始行的基础上+2，都和最后的后续行在同一行。那种情况下，花括号另起一行，避免该行和随后块里的内容在视觉上有混淆。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span>
<span class="k">where</span>
  <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span>
<span class="p">{</span>  <span class="c1">// GOOD.</span>
  <span class="k">for</span> <span class="n">current</span> <span class="k">in</span> <span class="n">elements</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span>
<span class="k">where</span>
  <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>  <span class="c1">// AVOID.</span>
  <span class="k">for</span> <span class="n">current</span> <span class="k">in</span> <span class="n">elements</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>For declarations that contain a <code class="highlighter-rouge">where</code> clause followed by generic constraints,
additional rules apply:</p>

<p>当声明里包含了用于范型约束的 <code class="highlighter-rouge">where</code> 关键字时，需要遵循的额外规则：</p>

<ol>
  <li>
    <p>If the generic constraint list exceeds the column limit when placed on the
same line as the return type, then a line break is first inserted <strong>before</strong>
the <code class="highlighter-rouge">where</code> keyword and the <code class="highlighter-rouge">where</code> keyword is indented at the same level as
the original line.</p>

    <p>如果范型约束列表和返回类型在同一行时超过了单行字符限制，在 <code class="highlighter-rouge">where</code> 关键字<strong>之前</strong>插入换行，并且和原始行缩进保持一致。</p>
  </li>
  <li>
    <p>If the generic constraint list still exceeds the column limit after inserting
the line break above, then the constraint list is oriented vertically with a
line break after the <code class="highlighter-rouge">where</code> keyword and a line break after the final
constraint.</p>

    <p>如果范型约束列表在换行之后依旧超过单行字符限制，那么在 <code class="highlighter-rouge">where</code> 关键字后换行，约束列表用垂直方向展示，并在最后一个约束后面换行。</p>
  </li>
</ol>

<p>Concrete examples of this are shown in the relevant subsections below.</p>

<p>具体例子见下面相关段落的内容。</p>

<p>This line-wrapping style ensures that the different parts of a declaration are
<em>quickly and easily identifiable to the reader</em> by using indentation and line
breaks, while also preserving the same indentation level for those parts
throughout the file. Specifically, it prevents the zig-zag effect that would be
present if the arguments are indented based on opening parentheses, as is common
in other languages:</p>

<p>这个换行风格能确保通过缩进和换行让_读者_可以_快速容易地识别_声明的不同部分，并且在文件中的这些部分缩进风格应该保持一致。具体来说，这能避免实参基于开边括号缩进而出现的锯齿效应，这在其他语言里很常见：</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span><span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>  <span class="c1">// AVOID.</span>
                                                 <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span>
    <span class="k">where</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="函数声明function-declarations">函数声明/Function Declarations</h4>

<pre class="lw-container">
<span class="lw-ub"><em>modifiers</em> func <em>name</em>(</span><span class="lw-br"><em>formal arguments</em></span><span class="lw-ub">)</span>{
<span class="lw-ub"><em>modifiers</em> func <em>name</em>(</span><span class="lw-br"><em>formal arguments</em></span><span class="lw-ub">) -&gt;</span><span class="lw-br"><em>result</em></span>{

<span class="lw-ub"><em>modifiers</em> func <em>name</em>&lt;</span><span class="lw-br"><em>generic arguments</em></span><span class="lw-ub">&gt;(</span><span class="lw-br"><em>formal arguments</em></span><span class="lw-ub">) throws -&gt;</span><span class="lw-br"><em>result</em></span>{

<span class="lw-ub"><em>modifiers</em> func <em>name</em>&lt;</span><span class="lw-br"><em>generic arguments</em></span><span class="lw-ub">&gt;(</span><span class="lw-br"><em>formal arguments</em></span><span class="lw-ub">) throws -&gt;</span><span class="lw-br"><em>result</em></span><span class="lw-ub">where</span><span class="lw-br"><em>generic constraints</em></span>{
</pre>

<p>Applying the rules above from left to right gives us the following
line-wrapping:</p>

<p>将上面的规则从左到右应用得到下面的换行：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">index</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Index</span><span class="p">?</span> <span class="k">where</span> <span class="kt">Elements</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Element</span><span class="p">,</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="k">for</span> <span class="n">current</span> <span class="k">in</span> <span class="n">elements</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Function declarations in protocols that are terminated with a closing
parenthesis (<code class="highlighter-rouge">)</code>) may place the parenthesis on the same line as the final
argument <strong>or</strong> on its own line.</p>

<p>协议里以闭边括号（<code class="highlighter-rouge">)</code>）结束的函数声明可以将括号和最后的实参放在同一行<strong>或者</strong>另起一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">ContrivedExampleDelegate</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">contrivedExample</span><span class="p">(</span>
    <span class="n">_</span> <span class="nv">contrivedExample</span><span class="p">:</span> <span class="kt">ContrivedExample</span><span class="p">,</span>
    <span class="n">willDoSomethingTo</span> <span class="nv">someValue</span><span class="p">:</span> <span class="kt">SomeValue</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">ContrivedExampleDelegate</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">contrivedExample</span><span class="p">(</span>
    <span class="n">_</span> <span class="nv">contrivedExample</span><span class="p">:</span> <span class="kt">ContrivedExample</span><span class="p">,</span>
    <span class="n">willDoSomethingTo</span> <span class="nv">someValue</span><span class="p">:</span> <span class="kt">SomeValue</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If types are complex and/or deeply nested, individual elements in the
arguments/constraints lists and/or the return type may also need to be wrapped.
In these rare cases, the same line-wrapping rules apply to those parts as apply
to the declaration itself.</p>

<p>如果类型很复杂和/或有深层嵌套，在作为实参/约束列表和/或返回类型的单个元素时也可能需要换行。在这种罕见情况下，使用和声明一致的换行规则。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="n">performanceTrackingIndex</span><span class="o">&lt;</span><span class="kt">Elements</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">of</span> <span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span>
  <span class="k">in</span> <span class="nv">collection</span><span class="p">:</span> <span class="kt">Elements</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span>
  <span class="kt">Element</span><span class="o">.</span><span class="kt">Index</span><span class="p">?,</span>
  <span class="kt">PerformanceTrackingIndexStatistics</span><span class="o">.</span><span class="kt">Timings</span><span class="p">,</span>
  <span class="kt">PerformanceTrackingIndexStatistics</span><span class="o">.</span><span class="kt">SpaceUsed</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However, <code class="highlighter-rouge">typealias</code>es or some other means are often a better way to simplify
complex declarations whenever possible.</p>

<p>然而，如果可以用 <code class="highlighter-rouge">typealias</code> 或其他手段简化复杂声明通常是更好的解决方法。</p>

<h4 id="类型和拓展声明type-and-extension-declarations">类型和拓展声明/Type and Extension Declarations</h4>

<p>The examples below apply equally to <code class="highlighter-rouge">class</code>, <code class="highlighter-rouge">struct</code>, <code class="highlighter-rouge">enum</code>, <code class="highlighter-rouge">extension</code>, and
<code class="highlighter-rouge">protocol</code> (with the obvious exception that all but the first do not have
superclasses in their inheritance list, but they are otherwise structurally
similar).</p>

<p>下面的例子同样适用于 <code class="highlighter-rouge">class</code>，<code class="highlighter-rouge">struct</code>，<code class="highlighter-rouge">enum</code>，<code class="highlighter-rouge">extension</code> 和 <code class="highlighter-rouge">protocol</code>（除了第一个的继承列表里有父类外，其余结构都是类似的）。</p>

<pre class="lw-container">
<span class="lw-ub"><em>modifiers</em> class <em>Name</em></span>{

<span class="lw-ub"><em>modifiers</em> class <em>Name</em>:</span><span class="lw-br"><em>superclass and protocols</em></span>{

<span class="lw-ub"><em>modifiers</em> class <em>Name</em>&lt;</span><span class="lw-br"><em>generic arguments</em></span><span class="lw-ub">&gt;:</span><span class="lw-br"><em>superclass and protocols</em></span>{

<span class="lw-ub"><em>modifiers</em> class <em>Name</em>&lt;</span><span class="lw-br"><em>generic arguments</em></span><span class="lw-ub">&gt;:</span><span class="lw-br"><em>superclass and protocols</em></span><span class="lw-ub">where</span><span class="lw-br"><em>generic constraints</em></span>{
</pre>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">MyClass</span><span class="p">:</span>
  <span class="kt">MySuperclass</span><span class="p">,</span>
  <span class="kt">MyProtocol</span><span class="p">,</span>
  <span class="kt">SomeoneElsesProtocol</span><span class="p">,</span>
  <span class="kt">SomeFrameworkProtocol</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">MyContainer</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="kt">MyContainerSuperclass</span><span class="p">,</span>
  <span class="kt">MyContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeoneElsesContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeFrameworkContainerProtocol</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">MyContainer</span><span class="o">&lt;</span><span class="kt">BaseCollection</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="kt">MyContainerSuperclass</span><span class="p">,</span>
  <span class="kt">MyContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeoneElsesContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeFrameworkContainerProtocol</span>
<span class="k">where</span> <span class="kt">BaseCollection</span><span class="p">:</span> <span class="kt">Collection</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">MyContainer</span><span class="o">&lt;</span><span class="kt">BaseCollection</span><span class="o">&gt;</span><span class="p">:</span>
  <span class="kt">MyContainerSuperclass</span><span class="p">,</span>
  <span class="kt">MyContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeoneElsesContainerProtocol</span><span class="p">,</span>
  <span class="kt">SomeFrameworkContainerProtocol</span>
<span class="k">where</span>
  <span class="kt">BaseCollection</span><span class="p">:</span> <span class="kt">Collection</span><span class="p">,</span>
  <span class="kt">BaseCollection</span><span class="o">.</span><span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span><span class="p">,</span>
  <span class="kt">BaseCollection</span><span class="o">.</span><span class="kt">Element</span><span class="p">:</span> <span class="kt">SomeOtherProtocolOnlyUsedToForceLineWrapping</span>
<span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="函数调用function-calls">函数调用/Function Calls</h4>

<p>When a function call is line-wrapped, each argument is written on its own line,
indented +2 from the original line.</p>

<p>当函数调用需要换行时，每一个实参单独一行，并在原始行缩进基础上 +2。</p>

<p>As with function declarations, if the function call terminates its enclosing
statement and ends with a closing parenthesis (<code class="highlighter-rouge">)</code>) (that is, it has no trailing
closure), then the parenthesis may be placed <strong>either</strong> on the same line as the
final argument <strong>or</strong> on its own line.</p>

<p>和函数声明一样，如果函数调用的语句以闭边括号（<code class="highlighter-rouge">)</code>）结束（意味着没有尾随闭包），括号<strong>既可以</strong>和最后一个实参在同一行<strong>也可以</strong>另起一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span>
  <span class="nv">of</span><span class="p">:</span> <span class="n">veryLongElementVariableName</span><span class="p">,</span>
  <span class="nv">in</span><span class="p">:</span> <span class="n">aCollectionOfElementsThatAlsoHappensToHaveALongName</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span>
  <span class="nv">of</span><span class="p">:</span> <span class="n">veryLongElementVariableName</span><span class="p">,</span>
  <span class="nv">in</span><span class="p">:</span> <span class="n">aCollectionOfElementsThatAlsoHappensToHaveALongName</span>
<span class="p">)</span>
</code></pre></div></div>

<p>If the function call ends with a trailing closure and the closure’s signature
must be wrapped, then place it on its own line and wrap the argument list in
parentheses to distinguish it from the body of the closure below it.</p>

<p>如果函数调用以尾随闭包结束，并且闭包签名需要换行的话，另起一行并将实参列表包在括号中以便和下面的闭包体区分。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">someAsynchronousAction</span><span class="o">.</span><span class="nf">execute</span><span class="p">(</span><span class="nv">withDelay</span><span class="p">:</span> <span class="n">howManySeconds</span><span class="p">,</span> <span class="nv">context</span><span class="p">:</span> <span class="n">actionContext</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">completion</span><span class="p">)</span> <span class="k">in</span>
  <span class="nf">doSomething</span><span class="p">(</span><span class="nv">withContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
  <span class="nf">completion</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="控制流语句control-flow-statements">控制流语句/Control Flow Statements</h4>

<p>When a control flow statement (such as <code class="highlighter-rouge">if</code>, <code class="highlighter-rouge">guard</code>, <code class="highlighter-rouge">while</code>, or <code class="highlighter-rouge">for</code>) is
wrapped, the first continuation line is indented to the same position as the
token following the control flow keyword. Additional continuation lines are
indented at that same position if they are syntactically parallel elements, or
in +2 increments from that position if they are syntactically nested.</p>

<p>当控制流语句（例如 <code class="highlighter-rouge">if</code>,<code class="highlighter-rouge">gurad</code>,<code class="highlighter-rouge">while</code> 或 <code class="highlighter-rouge">for</code>）需要换行时，首个后续行的缩进和紧接着控制流关键字的元素保持一致。其余的后续行如果是语法上平级的元素，那么缩进也保持一致，如果语法上有嵌套层级，则在原来缩进基础上+2。</p>

<p>The open brace (<code class="highlighter-rouge">{</code>) preceding the body of the control flow statement can either
be placed on the same line as the last continuation line or on the next line,
at the same indentation level as the beginning of the statement. For <code class="highlighter-rouge">guard</code>
statements, the <code class="highlighter-rouge">else {</code> must be kept together, either on the same line or on
the next line.</p>

<p>控制流语句执行体前面开边花括号（<code class="highlighter-rouge">{</code>）既可以和最后的条件同一行也可以另起一行，并和该语句缩进保持一致。对于 <code class="highlighter-rouge">guard</code> 语句， <code class="highlighter-rouge">else {</code> 必须连在一起，不管是在同一行中还是另起一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nf">aBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
   <span class="nf">aDifferentBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
   <span class="nf">yetAnotherBooleanValueThatContributesToTheWrapping</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nf">aBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
   <span class="nf">aDifferentBooleanValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
   <span class="nf">yetAnotherBooleanValueThatContributesToTheWrapping</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
   <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
   <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThingThatForcesTheBraceToBeWrapped</span><span class="p">()</span>
<span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
      <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">guard</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">aValueReturnedByAVeryLongOptionalThing</span><span class="p">(),</span>
      <span class="k">let</span> <span class="nv">value2</span> <span class="o">=</span> <span class="nf">aDifferentValueReturnedByAVeryLongOptionalThing</span><span class="p">()</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">collection</span>
    <span class="k">where</span> <span class="n">element</span><span class="o">.</span><span class="n">happensToHaveAVeryLongPropertyNameThatYouNeedToCheck</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="其他表达式other-expressions">其他表达式/Other Expressions</h4>

<p>When line-wrapping other expressions that are not function calls (as described
above), the second line (the one immediately following the first break) is
indented exactly +2 from the original line.</p>

<p>非函数调用（上面提到的）的其他表达式换行时，第二行（在第一个换行后的行）的缩进在原始行的基础上+2。</p>

<p>When there are multiple continuation lines, indentation may be varied in
increments of +2 as needed. In general, two continuation lines use the same
indentation level if and only if they begin with syntactically parallel
elements. However, if there are many continuation lines caused by long wrapped
expressions, consider splitting them into multiple statements using temporary
variables when possible.</p>

<p>当有多个后续行时，缩进会根据需要在原来的基础上 +2 递增变化。通常来说，有且仅当两个后续行以语法上平级的元素开始时才使用相同的缩进。然而，如果因为很长的表达式产生了很多个后续行，考虑将它分隔成多个语句的可能性，并使用临时变量。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">anExpression</span> <span class="o">+</span> <span class="n">thatIsMadeUpOf</span> <span class="o">*</span> <span class="n">aLargeNumber</span> <span class="o">+</span>
  <span class="n">ofTerms</span> <span class="o">/</span> <span class="n">andTherefore</span> <span class="o">%</span> <span class="n">mustBeWrapped</span> <span class="o">+</span> <span class="p">(</span>
    <span class="n">andWeWill</span> <span class="o">-</span> <span class="n">keepMakingItLonger</span> <span class="o">*</span> <span class="n">soThatWeHave</span> <span class="o">/</span> <span class="n">aContrivedExample</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="n">anExpression</span> <span class="o">+</span> <span class="n">thatIsMadeUpOf</span> <span class="o">*</span> <span class="n">aLargeNumber</span> <span class="o">+</span>
    <span class="n">ofTerms</span> <span class="o">/</span> <span class="n">andTherefore</span> <span class="o">%</span> <span class="n">mustBeWrapped</span> <span class="o">+</span> <span class="p">(</span>
        <span class="n">andWeWill</span> <span class="o">-</span> <span class="n">keepMakingItLonger</span> <span class="o">*</span> <span class="n">soThatWeHave</span> <span class="o">/</span> <span class="n">aContrivedExample</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="水平空格horizontal-whitespace">水平空格/Horizontal Whitespace</h3>

<blockquote>
  <p><strong>Terminology note:</strong> In this section, <em>horizontal whitespace</em> refers to
<em>interior</em> space. These rules are never interpreted as requiring or forbidding
additional space at the start of a line.</p>

  <p><strong>术语说明：</strong>在这个章节，_水平空格_指的是_内部_空格。这些规则不适用于行开始时需要或禁止的额外空格。</p>
</blockquote>

<p>Beyond where required by the language or other style rules, and apart from
literals and comments, a single Unicode space also appears in the following
places <strong>only</strong>:</p>

<p>根据语言要求或其他代码风格的规则，除了字面量和注释外的单个 Unicode 空格<strong>只能</strong>在下面这些情况出现：</p>

<ol>
  <li>
    <p>Separating any reserved word starting a conditional or switch statement (such
as <code class="highlighter-rouge">if</code>, <code class="highlighter-rouge">guard</code>, <code class="highlighter-rouge">while</code>, or <code class="highlighter-rouge">switch</code>) from the expression that follows it
if that expression starts with an open parenthesis (<code class="highlighter-rouge">(</code>).</p>

    <p>条件或 switch 语句（例如 <code class="highlighter-rouge">if</code>，<code class="highlighter-rouge">guard</code>，<code class="highlighter-rouge">while</code> 或者 <code class="highlighter-rouge">switch</code>）开始的任何保留关键字要和它之后的表达式分隔开，如果该表达式是以开边括号（<code class="highlighter-rouge">(</code>）开始的。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Before any closing curly brace (<code class="highlighter-rouge">}</code>) that follows code on the same line,
before any open curly brace (<code class="highlighter-rouge">{</code>), and after any open curly brace (<code class="highlighter-rouge">{</code>) that
is followed by code on the same line.</p>

    <p>在同一行代码后面的闭边花括号（<code class="highlighter-rouge">}</code>）之前，任何开边话括号（<code class="highlighter-rouge">{</code>）之前，后续代码在同一行的开边花括号（<code class="highlighter-rouge">{</code>）之后。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nonNegativeCubes</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span><span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">}</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nonNegativeCubes</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span> <span class="o">.</span><span class="n">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">}</span>
<span class="k">let</span> <span class="nv">nonNegativeCubes</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">map</span><span class="p">{</span><span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span><span class="p">}</span><span class="o">.</span><span class="n">filter</span><span class="p">{</span><span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><em>On both sides</em> of any binary or ternary operator, including the
“operator-like” symbols described below, with exceptions noted at the end:</p>

    <p>在二元或者三元运算符的每一侧，包括下面描述的“类运算符”，除了最后的例外说明：</p>

    <ol>
      <li>
        <p>The <code class="highlighter-rouge">=</code> sign used in assignment, initialization of variables/properties,
and default arguments in functions.</p>

        <p><code class="highlighter-rouge">=</code> 运算符用在赋值，变量/属性的构造过程以及函数里的默认实参时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="mi">5</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">initialValue</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">x</span><span class="o">=</span><span class="mi">5</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">],</span> <span class="nv">initialValue</span><span class="p">:</span> <span class="kt">Int</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>The ampersand (<code class="highlighter-rouge">&amp;</code>) in a protocol composition type.</p>

        <p>And 符号（<code class="highlighter-rouge">&amp;</code>）用在协议组合类型时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sayHappyBirthday</span><span class="p">(</span><span class="n">to</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">NameProviding</span> <span class="o">&amp;</span> <span class="kt">AgeProviding</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sayHappyBirthday</span><span class="p">(</span><span class="n">to</span> <span class="nv">person</span><span class="p">:</span> <span class="kt">NameProviding</span><span class="o">&amp;</span><span class="kt">AgeProviding</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>The operator symbol in a function declaring/implementing that operator.</p>

        <p>运算符用在函数声明/实现时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span><span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">MyType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>The arrow (<code class="highlighter-rouge">-&gt;</code>) preceding the return type of a function.</p>

        <p>箭头（<code class="highlighter-rouge">-&gt;</code>）用在函数的返回类型之前时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span><span class="o">-&gt;</span><span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>Exception:</strong> There is no space on either side of the dot (<code class="highlighter-rouge">.</code>) used to
reference value and type members.</p>

        <p><strong>例外：</strong>点（<code class="highlighter-rouge">.</code>）用在引用值和类型成员时两侧都没有空格。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">width</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">bounds</span><span class="o">.</span><span class="n">width</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">width</span> <span class="o">=</span> <span class="n">view</span> <span class="o">.</span> <span class="n">bounds</span> <span class="o">.</span> <span class="n">width</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><strong>Exception:</strong> There is no space on either side of the <code class="highlighter-rouge">..&lt;</code> or <code class="highlighter-rouge">...</code>
operators used in range expressions.</p>

        <p><strong>例外：</strong><code class="highlighter-rouge">..&lt;</code> 或者 <code class="highlighter-rouge">…</code> 运算符用在范围表达式时两侧都没空格。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="mi">5</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="k">let</span> <span class="nv">substring</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">index</span><span class="o">..&lt;</span><span class="n">string</span><span class="o">.</span><span class="n">endIndex</span><span class="p">]</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="mi">1</span> <span class="o">...</span> <span class="mi">5</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="k">let</span> <span class="nv">substring</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">index</span> <span class="o">..&lt;</span> <span class="n">string</span><span class="o">.</span><span class="n">endIndex</span><span class="p">]</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>After, but not before, the comma (<code class="highlighter-rouge">,</code>) in parameter lists and in
tuple/array/dictionary literals.</p>

    <p>逗号（<code class="highlighter-rouge">,</code>）用在形参列表和元组/数组/字典字面量时，在逗号后面而不是前面。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="p">,</span><span class="mi">2</span> <span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="p">,</span> <span class="mi">2</span> <span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>After, but not before, the colon (<code class="highlighter-rouge">:</code>) in</p>

    <p>冒号（<code class="highlighter-rouge">:</code>）的后面而不是前面用在</p>

    <ol>
      <li>
        <p>Superclass/protocol conformance lists and generic constraints.</p>

        <p>父类/协议遵循列表和范型约束时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">HashTable</span><span class="p">:</span> <span class="kt">Collection</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="kd">struct</span> <span class="kt">AnyEquatable</span><span class="o">&lt;</span><span class="kt">Wrapped</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">HashTable</span> <span class="p">:</span> <span class="kt">Collection</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="kd">struct</span> <span class="kt">AnyEquatable</span><span class="o">&lt;</span><span class="kt">Wrapped</span> <span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span> <span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>Function argument labels and tuple element labels.</p>

        <p>函数实参标签和元组元素标签时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">tuple</span><span class="p">:</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">tuple</span><span class="p">:</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span><span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span><span class="kt">Int</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">tuple</span><span class="p">:</span> <span class="p">(</span><span class="nv">x</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">)</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
      
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span> <span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>Variable/property declarations with explicit types.</p>

        <p>变量/属性的类型显式声明时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">number</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">number</span><span class="p">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">let</span> <span class="nv">number</span> <span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>Shorthand dictionary type names.</p>

        <p>字典类型缩写时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">nameAgeMap</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">nameAgeMap</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span><span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">var</span> <span class="nv">nameAgeMap</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span> <span class="p">:</span> <span class="kt">Int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>Dictionary literals.</p>

        <p>字典字面量时。</p>

        <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nameAgeMap</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Ed"</span><span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Timmy"</span><span class="p">:</span> <span class="mi">9</span><span class="p">]</span>
</code></pre></div>        </div>

        <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nameAgeMap</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Ed"</span><span class="p">:</span><span class="mi">40</span><span class="p">,</span> <span class="s">"Timmy"</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
<span class="k">let</span> <span class="nv">nameAgeMap</span> <span class="o">=</span> <span class="p">[</span><span class="s">"Ed"</span> <span class="p">:</span> <span class="mi">40</span><span class="p">,</span> <span class="s">"Timmy"</span> <span class="p">:</span> <span class="mi">9</span><span class="p">]</span>
</code></pre></div>        </div>
      </li>
    </ol>
  </li>
  <li>
    <p>At least two spaces before and exactly one space after the double slash
(<code class="highlighter-rouge">//</code>) that begins an end-of-line comment.</p>

    <p>双斜杠（<code class="highlighter-rouge">//</code>）用于开始行结束的注释时，双斜杠之前最少两个空格，之后正好一个空格。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">initialFactor</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1">// Warm up the modulator.</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">initialFactor</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1">//    Warm up the modulator.</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Outside, but not inside, the brackets of an array or dictionary literals and
the parentheses of a tuple literal.</p>

    <p>括号用于数组、字典或元组字面量时，括号外面而不是里面。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div>    </div>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">numbers</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="水平对齐horizontal-alignment">水平对齐/Horizontal Alignment</h3>

<blockquote>
  <p><strong>Terminology note:</strong> <em>Horizontal alignment</em> is the practice of adding a
variable number of additional spaces in your code with the goal of making
certain tokens appear directly below certain other tokens on previous lines.</p>

  <p><strong>术语说明：</strong>_水平对齐_是一种约定，通过在代码中添加不同数量的空格让某些元素直接显示在前面行中该类型的其他元素下面。</p>
</blockquote>

<p>Horizontal alignment is forbidden except when writing obviously tabular data
where omitting the alignment would be harmful to readability. In other cases
(for example, lining up the types of stored property declarations in a <code class="highlighter-rouge">struct</code>
or <code class="highlighter-rouge">class</code>), horizontal alignment is an invitation for maintenance problems if a
new member is introduced that requires every other member to be realigned.</p>

<p>水平对齐是禁止的，除了在分明的表格数据里，省略会不利于可读性之外。其他情况下（例如，对 <code class="highlighter-rouge">struct</code> 或  <code class="highlighter-rouge">class</code> 里的存储属性声明的类型进行对齐）水平对齐会引起维护问题，因为在新的成员引入时其余所有的成员都需要重新对齐。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">DataPoint</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="nv">primaryColor</span><span class="p">:</span> <span class="kt">UIColor</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">DataPoint</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span>        <span class="kt">Int</span>
  <span class="k">var</span> <span class="nv">primaryColor</span><span class="p">:</span> <span class="kt">UIColor</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="垂直空行vertical-whitespace">垂直空行/Vertical Whitespace</h3>

<p>A single blank line appears in the following locations:</p>

<p>单独的空白行在以下这些情况下出现：</p>

<ol>
  <li>
    <p>Between consecutive members of a type: properties, initializers, methods,
enum cases, and nested types, <strong>except that</strong>:</p>

    <p>在类型中这些连续成员之间：属性，构造器，方法，枚举情况，嵌套类型，<strong>除了</strong>：</p>

    <ol>
      <li>
        <p>A blank line is optional between two consecutive stored properties or two
enum cases whose declarations fit entirely on a single line. Such blank
lines can be used to create <em>logical groupings</em> of these declarations.</p>

        <p>两个连续的存储属性或者枚举里两个也完全适合声明在一行里的 case，之间空白行是可选的。这时候空白行可以用来将这些声明进行_逻辑分组_。</p>
      </li>
      <li>
        <p>A blank line is optional between two extremely closely related properties
that do not otherwise meet the criterion above; for example, a private
stored property and a related public computed property.</p>
      </li>
    </ol>

    <p>不适用于前面规则，但两个属性非常相关，之间的空白行也是可选的。例如，一个私有的存储属性和它相关的公开计算属性。</p>
  </li>
  <li>
    <p><em>Only as needed</em> between statements to organize code into logical
subsections.</p>

    <p><strong>只有需要</strong>用于组织代码进行逻辑分段的语句之间。</p>
  </li>
  <li>
    <p><em>Optionally</em> before the first member or after the last member of a type
(neither is encouraged nor discouraged).</p>

    <p>类型的第一个成员之前或者最后一个成员之后的空白行是_可选的_（不赞成也不反对）。</p>
  </li>
  <li>
    <p>Anywhere explicitly required by other sections of this document.</p>

    <p>本文档中其他章节中明确要求的地方。</p>
  </li>
</ol>

<p><em>Multiple</em> blank lines are permitted, but never required (nor encouraged). If
you do use multiple consecutive blank lines, do so consistently throughout your
code base.</p>

<p>_多个_空白行是允许的，但不是必须的（不赞成）。如果你使用多个连续的空白行，那么在你的代码里应该贯彻到底。</p>

<h3 id="括号parentheses">括号/Parentheses</h3>

<p>Parentheses are <strong>not</strong> used around the top-most expression that follows an
<code class="highlighter-rouge">if</code>, <code class="highlighter-rouge">guard</code>, <code class="highlighter-rouge">while</code>, or <code class="highlighter-rouge">switch</code> keyword.</p>

<p><code class="highlighter-rouge">if</code>，<code class="highlighter-rouge">guard</code>，<code class="highlighter-rouge">while</code> 或 <code class="highlighter-rouge">switch</code> 关键字后面的顶层表达式<strong>不需要</strong>使用括号。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"x is zero"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"x is zero"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">z</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"..."</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Optional grouping parentheses are omitted only when the author and the reviewer
agree that there is no reasonable chance that the code will be misinterpreted
without them, nor that they would have made the code easier to read. It is <em>not</em>
reasonable to assume that every reader has the entire Swift operator precedence
table memorized.</p>

<p>分组括号是可选的，只有当作者和审查者觉得没有也不会令代码容易误解，或者会让代码更容易阅读时才可以被省略。<strong>不</strong>要认为每个阅读者都能记得完整的 Swift 操作符优先级表格。</p>

<h2 id="特定结构格式化formatting-specific-constructs">特定结构格式化/Formatting Specific Constructs</h2>

<h3 id="非文档注释non-documentation-comments">非文档注释/Non-Documentation Comments</h3>

<p>Non-documentation comments always use the double-slash format (<code class="highlighter-rouge">//</code>), never the
C-style block format (<code class="highlighter-rouge">/* ... */</code>).</p>

<p>非文档注释总是用双斜杠进行格式化（<code class="highlighter-rouge">//</code>），而不要使用 C 风格的块格式化（<code class="highlighter-rouge">/* ... */</code>）。</p>

<h3 id="属性properties">属性/Properties</h3>

<p>Local variables are declared close to the point at which they are first used
(within reason) to minimize their scope.</p>

<p>局部变量尽量声明在接近首次使用的地方，（在合理的情况下）最小化作用域。</p>

<p>With the exception of tuple destructuring, every <code class="highlighter-rouge">let</code> or <code class="highlighter-rouge">var</code> statement
(whether a property or a local variable) declares exactly one variable.</p>

<p>除了元组的解构时，每个 <code class="highlighter-rouge">let</code> 或者 <code class="highlighter-rouge">var</code> 语句（无论是属性或者局部变量）只声明一个变量。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="k">var</span> <span class="nv">b</span> <span class="o">=</span> <span class="mi">10</span>

<span class="nf">let</span> <span class="p">(</span><span class="n">quotient</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">=</span> <span class="nf">divide</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div></div>

<h3 id="switch-语句switch-statements">Switch 语句/Switch Statements</h3>

<p>Case statements are indented at the <em>same</em> level as the switch statement to
which they belong; the statements inside the case blocks are then indented +2
spaces from that level.</p>

<p>Case 语句的缩进和它们的 switch 语句保持_一致_;case 块里的语句在该缩进基础上+2空格。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">order</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">ascending</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Ascending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">descending</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Descending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">same</span><span class="p">:</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Same"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">order</span> <span class="p">{</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">ascending</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Ascending"</span><span class="p">)</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">descending</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Descending"</span><span class="p">)</span>
  <span class="k">case</span> <span class="o">.</span><span class="nv">same</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Same"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">order</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">ascending</span><span class="p">:</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Ascending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">descending</span><span class="p">:</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Descending"</span><span class="p">)</span>
<span class="k">case</span> <span class="o">.</span><span class="nv">same</span><span class="p">:</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"Same"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="枚举-caseenum-cases">枚举 Case/Enum Cases</h3>

<p>In general, there is only one <code class="highlighter-rouge">case</code> per line in an <code class="highlighter-rouge">enum</code>. The comma-delimited
form may be used only when none of the cases have associated values or raw
values, all cases fit on a single line, and the cases do not need further
documentation because their meanings are obvious from their names.</p>

<p>通常来说，在一个 <code class="highlighter-rouge">enum</code> 里每行只有一个 <code class="highlighter-rouge">case</code>。逗号分隔形式只能在 case 都没有关联值或者原始值时使用，所有 case 都能从名字明确其含义而不需要额外的注释，就可以写在同一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">comma</span>
  <span class="k">case</span> <span class="n">semicolon</span>
  <span class="k">case</span> <span class="n">identifier</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">comma</span><span class="p">,</span> <span class="n">semicolon</span><span class="p">,</span> <span class="n">identifier</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">comma</span>
  <span class="k">case</span> <span class="n">semicolon</span>
  <span class="k">case</span> <span class="nf">identifier</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">Token</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">comma</span><span class="p">,</span> <span class="n">semicolon</span><span class="p">,</span> <span class="nf">identifier</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When all cases of an <code class="highlighter-rouge">enum</code> must be <code class="highlighter-rouge">indirect</code>, the <code class="highlighter-rouge">enum</code> itself is declared
<code class="highlighter-rouge">indirect</code> and the keyword is omitted on the individual cases.</p>

<p>当 <code class="highlighter-rouge">enum</code> 里所有 case 都需要被声明为 <code class="highlighter-rouge">indirect</code> 时，该 <code class="highlighter-rouge">enum</code> 就声明为 <code class="highlighter-rouge">indirect</code>，单独 case 前面的关键字就可以省略。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">indirect</span> <span class="kd">enum</span> <span class="kt">DependencyGraphNode</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nf">userDefined</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
  <span class="k">case</span> <span class="nf">synthesized</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">DependencyGraphNode</span> <span class="p">{</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">userDefined</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">synthesized</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="p">[</span><span class="kt">DependencyGraphNode</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When an <code class="highlighter-rouge">enum</code> case does not have associated values, empty parentheses are never
present.</p>

<p>当 <code class="highlighter-rouge">enum</code> 的 case 没有关联值时，不应该出现空的括号。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">node</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">empty</span>  <span class="c1">// GOOD.</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">node</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="p">)</span>
  <span class="k">case</span> <span class="nf">empty</span><span class="p">()</span>  <span class="c1">// AVOID.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The cases of an enum must follow a logical ordering that the author could
explain if asked. If there is no obviously logical ordering, use a
lexicographical ordering based on the cases’ names.</p>

<p>枚举的 case 必须遵循一定的可解释排序逻辑。如果没有明显的排序逻辑，按照 case 名字的首字母排序。</p>

<p>In the following example, the cases are arranged in numerical order based on the
underlying HTTP status code and blank lines are used to separate groups.</p>

<p>在下面的例子中，case 根据其表示的 HTTP 状态码数字进行排序，并通过空行进行分组。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">HTTPStatus</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">200</span>

  <span class="k">case</span> <span class="n">badRequest</span> <span class="o">=</span> <span class="mi">400</span>
  <span class="k">case</span> <span class="n">notAuthorized</span> <span class="o">=</span> <span class="mi">401</span>
  <span class="k">case</span> <span class="n">paymentRequired</span> <span class="o">=</span> <span class="mi">402</span>
  <span class="k">case</span> <span class="n">forbidden</span> <span class="o">=</span> <span class="mi">403</span>
  <span class="k">case</span> <span class="n">notFound</span> <span class="o">=</span> <span class="mi">404</span>

  <span class="k">case</span> <span class="n">internalServerError</span> <span class="o">=</span> <span class="mi">500</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The following version of the same enum is less readable. Although the cases are
ordered lexicographically, the meaningful groupings of related values has been
lost.</p>

<p>同样的枚举，下面这个版本的写法可读性就差一些。尽管 case 根据字母排序，但是却失去了对关联值含义的表达。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="kt">HTTPStatus</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">badRequest</span> <span class="o">=</span> <span class="mi">400</span>
  <span class="k">case</span> <span class="n">forbidden</span> <span class="o">=</span> <span class="mi">403</span>
  <span class="k">case</span> <span class="n">internalServerError</span> <span class="o">=</span> <span class="mi">500</span>
  <span class="k">case</span> <span class="n">notAuthorized</span> <span class="o">=</span> <span class="mi">401</span>
  <span class="k">case</span> <span class="n">notFound</span> <span class="o">=</span> <span class="mi">404</span>
  <span class="k">case</span> <span class="n">ok</span> <span class="o">=</span> <span class="mi">200</span>
  <span class="k">case</span> <span class="n">paymentRequired</span> <span class="o">=</span> <span class="mi">402</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="尾随闭包trailing-closures">尾随闭包/Trailing Closures</h3>

<p>Functions should not be overloaded such that two overloads differ <em>only</em> by the
name of their trailing closure argument. Doing so prevents using trailing
closure syntax—when the label is not present, a call to the function with
a trailing closure is ambiguous.</p>

<p>函数重载时，不能出现两个重载_只有_尾随闭包的实参名字有区别的情况。</p>

<p>Consider the following example, which prohibits using trailing closure syntax to
call <code class="highlighter-rouge">greet</code>:</p>

<p>考虑下面的例子，这样会不允许用尾随闭包语法来调用 <code class="highlighter-rouge">greet</code>：</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">enthusiastically</span> <span class="nv">nameProvider</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Hello, </span><span class="se">\(</span><span class="nf">nameProvider</span><span class="p">()</span><span class="se">)</span><span class="s">! It's a pleasure to see you!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">apathetically</span> <span class="nv">nameProvider</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Oh, look. It's </span><span class="se">\(</span><span class="nf">nameProvider</span><span class="p">()</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">greet</span> <span class="p">{</span> <span class="s">"John"</span> <span class="p">}</span>  <span class="c1">// error: ambiguous use of 'greet'</span>
</code></pre></div></div>

<p>This example is fixed by differentiating some part of the function name other
than the closure argument—in this case, the base name:</p>

<p>这个例子可以用除闭包实参外函数名的一部分差异来区分——具体这种情况下，可以用函数的基础名字：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">greetEnthusiastically</span><span class="p">(</span><span class="n">_</span> <span class="nv">nameProvider</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Hello, </span><span class="se">\(</span><span class="nf">nameProvider</span><span class="p">()</span><span class="se">)</span><span class="s">! It's a pleasure to see you!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">greetApathetically</span><span class="p">(</span><span class="n">_</span> <span class="nv">nameProvider</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Oh, look. It's </span><span class="se">\(</span><span class="nf">nameProvider</span><span class="p">()</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">greetEnthusiastically</span> <span class="p">{</span> <span class="s">"John"</span> <span class="p">}</span>
<span class="n">greetApathetically</span> <span class="p">{</span> <span class="s">"not John"</span> <span class="p">}</span>
</code></pre></div></div>

<p>If a function call has multiple closure arguments, then <em>none</em> are called using
trailing closure syntax; <em>all</em> are labeled and nested inside the argument
list’s parentheses.</p>

<p>当一个函数调用有多个闭包实参，那么_都不_使用尾随闭包语法调用；_都_需要写出标签并放在在实参列表的括号里。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UIView</span><span class="o">.</span><span class="nf">animate</span><span class="p">(</span>
  <span class="nv">withDuration</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
  <span class="nv">animations</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">},</span>
  <span class="nv">completion</span><span class="p">:</span> <span class="p">{</span> <span class="n">finished</span> <span class="k">in</span>
    <span class="c1">// ...</span>
  <span class="p">})</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">UIView</span><span class="o">.</span><span class="nf">animate</span><span class="p">(</span>
  <span class="nv">withDuration</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
  <span class="nv">animations</span><span class="p">:</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">})</span> <span class="p">{</span> <span class="n">finished</span> <span class="k">in</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>If a function has a single closure argument and it is the final argument, then
it is <em>always</em> called using trailing closure syntax, except in the following
cases to resolve ambiguity or parsing errors:</p>

<p>如果函数只有一个闭包实参并且是最后的实参，那么_永远_使用尾随闭包语法调用它，除了下面这些解决歧义或者分析错误的情况：</p>

<ol>
  <li>
    <p>As described above, labeled closure arguments must be used to disambiguate
between two overloads with otherwise identical arguments lists.</p>

    <p>如上面所描述，必须使用带标签的闭包参数来消除两个其他实参列表都相同的重载之间的歧义。</p>
  </li>
  <li>
    <p>Labeled closure arguments must be used in control flow statements where the
body of the trailing closure would be parsed as the body of the control flow
statement.</p>

    <p>在控制流语句里必须使用带标签的闭包实参，因为尾随闭包会被解析成控制流语句的执行体。</p>
  </li>
</ol>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Timer</span><span class="o">.</span><span class="nf">scheduledTimer</span><span class="p">(</span><span class="nv">timeInterval</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="nv">repeats</span><span class="p">:</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Timer done!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">firstActive</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="nf">first</span><span class="p">(</span><span class="nv">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">isActive</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nf">process</span><span class="p">(</span><span class="n">firstActive</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Timer</span><span class="o">.</span><span class="nf">scheduledTimer</span><span class="p">(</span><span class="nv">timeInterval</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="nv">repeats</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">block</span><span class="p">:</span> <span class="p">{</span> <span class="n">timer</span> <span class="k">in</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"Timer done!"</span><span class="p">)</span>
<span class="p">})</span>

<span class="c1">// This example fails to compile.</span>
<span class="k">if</span> <span class="k">let</span> <span class="nv">firstActive</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="n">first</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">isActive</span> <span class="p">}</span> <span class="p">{</span>
  <span class="nf">process</span><span class="p">(</span><span class="n">firstActive</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When a function called with trailing closure syntax takes no other arguments,
empty parentheses (<code class="highlighter-rouge">()</code>) after the function name are <em>never</em> present.</p>

<p>如果函数调用使用的是尾随闭包语法且没有其他实参，函数名后面的空括号（<code class="highlighter-rouge">()</code>）_永远不_要出现。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">squares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">squares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="nf">map</span><span class="p">({</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">})</span>
<span class="k">let</span> <span class="nv">squares</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="nf">map</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span> <span class="p">}</span>
</code></pre></div></div>

<h3 id="末尾逗号trailing-commas">末尾逗号/Trailing Commas</h3>

<p>Trailing commas in array and dictionary literals are <em>required</em> when each
element is placed on its own line. Doing so produces cleaner diffs when items
are added to those literals later.</p>

<p>当数组和字典里字面量里每个元素独占一行时_需要_加上末尾逗号。这样做在这些字面量后续加入新的元素时会有更明显的区分。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">configurationKeys</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s">"bufferSize"</span><span class="p">,</span>
  <span class="s">"compression"</span><span class="p">,</span>
  <span class="s">"encoding"</span><span class="p">,</span>                                    <span class="c1">// GOOD.</span>
<span class="p">]</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">configurationKeys</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s">"bufferSize"</span><span class="p">,</span>
  <span class="s">"compression"</span><span class="p">,</span>
  <span class="s">"encoding"</span>                                     <span class="c1">// AVOID.</span>
<span class="p">]</span>
</code></pre></div></div>

<h3 id="数字字面量numeric-literals">数字字面量/Numeric Literals</h3>

<p>It is recommended but not required that long numeric literals (decimal,
hexadecimal, octal, and binary) use the underscore (<code class="highlighter-rouge">_</code>) separator to group
digits for readability when the literal has numeric value or when there exists a
domain-specific grouping.</p>

<p>当长数字字面量（十进制，十六进制，八进制和二进制）有数值或存在特定领域分组时建议使用下划线（<code class="highlighter-rouge">_</code>）对数字进行分组，但不强制。</p>

<p>Recommended groupings are three digits for decimal (thousands separators), four
digits for hexadecimal, four or eight digits for binary literals, or
value-specific field boundaries when they exist (such as three digits for octal
file permissions).</p>

<p>十进制建议每三个数字分组（按千数量级分隔），十六进制建议每四个数字分组，二进制建议每四或八个数字进行分组，或者根据存在的特定值的字段边界进行分组（例如八进制文件权限的三个数字）。</p>

<p>Do not group digits if the literal is an opaque identifier that does not have a
meaningful numeric value.</p>

<p>如果字面量是透明标识符且没有数值含义，则不要分组。</p>

<h3 id="注解attributes">注解/Attributes</h3>

<p>Parameterized attributes (such as <code class="highlighter-rouge">@availability(...)</code> or <code class="highlighter-rouge">@objc(...)</code>) are each
written on their own line immediately before the declaration to which they
apply, are lexicographically ordered, and are indented at the same level as the
declaration.</p>

<p>每个带参数的注解（例如 <code class="highlighter-rouge">@availability(…)</code> 或 <code class="highlighter-rouge">@objc(…)</code>）写在其适用声明的前面单独一行，并且按照首字母排序，缩进和声明保持一致。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@available(iOS 9.0, *)</span>
<span class="kd">public</span> <span class="kd">func</span> <span class="nf">coolNewFeature</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@available(iOS 9.0, *)</span> <span class="kd">public</span> <span class="kd">func</span> <span class="nf">coolNewFeature</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Attributes without parameters (for example, <code class="highlighter-rouge">@objc</code> without arguments,
<code class="highlighter-rouge">@IBOutlet</code>, or <code class="highlighter-rouge">@NSManaged</code>) are lexicographically ordered and <em>may</em> be placed
on the same line as the declaration if and only if they would fit on that line
without requiring the line to be rewrapped. If placing an attribute on the same
line as the declaration would require a declaration to be wrapped that
previously did not need to be wrapped, then the attribute is placed on its own
line.</p>

<p>不带参数的注解（例如不带参数的 <code class="highlighter-rouge">@objc</code> ，<code class="highlighter-rouge">@IBOutlet</code> 或者 <code class="highlighter-rouge">@NSManaged</code>）当且仅当不导致换行时_可以_按首字母排序与声明写在同一行。如果在声明的行增加该注解后导致需要换行的话，则将注解另起一行。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">MyViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
  <span class="kd">@IBOutlet</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="o">!</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="命名naming">命名/Naming</h2>

<h3 id="apple-api-代码风格指南apples-api-style-guidelines">Apple API 代码风格指南/Apple’s API Style Guidelines</h3>

<p>Apple’s
<a href="https://swift.org/documentation/api-design-guidelines/">official Swift naming and API design guidelines</a>
hosted on swift.org are considered part of this style guide and are followed as
if they were repeated here in their entirety.</p>

<p>这部分代码风格指南是参考 Apple 官方的 Swift 命名和 API 代码风格指南而成的，并且应该遵循那些在这里重复的部分。</p>

<h3 id="命名约定不涉及访问控制naming-conventions-are-not-access-control">命名约定不涉及访问控制/Naming Conventions Are Not Access Control</h3>

<p>Restricted access control (<code class="highlighter-rouge">internal</code>, <code class="highlighter-rouge">fileprivate</code>, or <code class="highlighter-rouge">private</code>) is preferred
for the purposes of hiding information from clients, rather than naming
conventions.</p>

<p>使用约定俗成的访问控制（<code class="highlighter-rouge">internal</code>，<code class="highlighter-rouge">fileprivate</code> 或 <code class="highlighter-rouge">private</code>）来达到隐藏信息的目的，而不要使用命名约定。</p>

<p>Naming conventions (such as prefixing a leading underscore) are only used in
rare situations when a declaration must be given higher visibility than is
otherwise desired in order to work around language limitations—for
example, a type that has a method that is only intended to be called by other
parts of a library implementation that crosses module boundaries and must
therefore be declared <code class="highlighter-rouge">public</code>.</p>

<p>命名约定（例如下划线前缀）只有在声明必须用到更高的可见性来解决语言限制的罕见情况下使用——例如，类型有一个方法，只打算被另一个库的实现跨模块调用，导致必须被声明为 <code class="highlighter-rouge">public</code> 的情况下。</p>

<h3 id="标识符identifiers">标识符/Identifiers</h3>

<p>In general, identifiers contain only 7-bit ASCII characters. Unicode identifiers
are allowed if they have a clear and legitimate meaning in the problem domain
of the code base (for example, Greek letters that represent mathematical
concepts) and are well understood by the team who owns the code.</p>

<p>通常来说，标识符只能包含 7 位 ASCII 码字符。Unicode 标识符只有在代码所需要解决的问题领域有明确且合理的含义（例如：希腊字母用于表达数学上的概念），并且能被团队成员理解的情况下才可以使用。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">smile</span> <span class="o">=</span> <span class="s">"😊"</span>
<span class="k">let</span> <span class="nv">deltaX</span> <span class="o">=</span> <span class="n">newX</span> <span class="o">-</span> <span class="n">previousX</span>
<span class="k">let</span> <span class="nv">Δx</span> <span class="o">=</span> <span class="n">newX</span> <span class="o">-</span> <span class="n">previousX</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">😊</span> <span class="o">=</span> <span class="s">"😊"</span>
</code></pre></div></div>

<h3 id="构造器initializers">构造器/Initializers</h3>

<p>For clarity, initializer arguments that correspond directly to a stored property
have the same name as the property. Explicit <code class="highlighter-rouge">self.</code> is used during assignment
to disambiguate them.</p>

<p>为了更明确地表达，构造器实参和其直接对应的存储属性同名。在赋值的时候使用显式 <code class="highlighter-rouge">self.</code> 来消除歧义。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span>

  <span class="c1">// GOOD.</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="k">self</span><span class="o">.</span><span class="n">phoneNumber</span> <span class="o">=</span> <span class="n">phoneNumber</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="kd">public</span> <span class="k">let</span> <span class="nv">phoneNumber</span><span class="p">:</span> <span class="kt">String</span>

  <span class="c1">// AVOID.</span>
  <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">name</span> <span class="nv">otherName</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="n">phoneNumber</span> <span class="nv">otherPhoneNumber</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">otherName</span>
    <span class="n">phoneNumber</span> <span class="o">=</span> <span class="n">otherPhoneNumber</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="静态属性和类属性static-and-class-properties">静态属性和类属性/Static and Class Properties</h3>

<p>Static and class properties that return instances of the declaring type are
<em>not</em> suffixed with the name of the type.</p>

<p>静态属性和类属性返回声明类型的实例时<strong>不需要</strong>加上该类型名字作后缀。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">UIColor</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">red</span><span class="p">:</span> <span class="kt">UIColor</span> <span class="p">{</span>                <span class="c1">// GOOD.</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="kt">URLSession</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">shared</span><span class="p">:</span> <span class="kt">URLSession</span> <span class="p">{</span>          <span class="c1">// GOOD.</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="kt">UIColor</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">redColor</span><span class="p">:</span> <span class="kt">UIColor</span> <span class="p">{</span>           <span class="c1">// AVOID.</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="kt">URLSession</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="kd">class</span> <span class="k">var</span> <span class="nv">sharedSession</span><span class="p">:</span> <span class="kt">URLSession</span> <span class="p">{</span>   <span class="c1">// AVOID.</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When a static or class property evaluates to a singleton instance of the
declaring type, the names <code class="highlighter-rouge">shared</code> and <code class="highlighter-rouge">default</code> are commonly used. This style
guide does not require specific names for these; the author should choose a name
that makes sense for the type.</p>

<p>当静态属性或者类属性用于描述该声明类型的单例实例时，通常使用 <code class="highlighter-rouge">shared</code> 和 <code class="highlighter-rouge">default</code> 作为名字。这个代码风格指南不强制要求使用这些命名，作者可以自行选择对该类型有意义的名字。</p>

<h3 id="全局常量global-constants">全局常量/Global Constants</h3>

<p>Like other variables, global constants are <code class="highlighter-rouge">lowerCamelCase</code>. Hungarian notation,
such as a leading <code class="highlighter-rouge">g</code> or <code class="highlighter-rouge">k</code>, is not used.</p>

<p>和其他变量类似，全局常量也使用 <code class="highlighter-rouge">lowerCamelCase(驼峰命名法)</code>。而不使用匈牙利命名法，例如以 <code class="highlighter-rouge">g</code> 或者 <code class="highlighter-rouge">k</code> 开头。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">secondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">SecondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">let</span> <span class="nv">kSecondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">let</span> <span class="nv">gSecondsPerMinute</span> <span class="o">=</span> <span class="mi">60</span>
<span class="k">let</span> <span class="nv">SECONDS_PER_MINUTE</span> <span class="o">=</span> <span class="mi">60</span>
</code></pre></div></div>

<h3 id="代理方法delegate-methods">代理方法/Delegate Methods</h3>

<p>Methods on delegate protocols and delegate-like protocols (such as data sources)
are named using the linguistic syntax described below, which is inspired by
Cocoa’s protocols.</p>

<p>代理协议和类似代理的协议（例如数据源协议）里的方法命名使用下面描述的口语化语法，这是受 Cocoa 框架里协议的命名启发而来。</p>

<blockquote>
  <p>The term “delegate’s source object” refers to the object that invokes methods
on the delegate. For example, a <code class="highlighter-rouge">UITableView</code> is the source object that
invokes methods on the <code class="highlighter-rouge">UITableViewDelegate</code> that is set as the view’s
<code class="highlighter-rouge">delegate</code> property.</p>

  <p>术语“代理源对象”指的是响应代理方法的对象。例如：<code class="highlighter-rouge">UITableView</code> 是响应视图 <code class="highlighter-rouge">delegate</code> 属性设置的 <code class="highlighter-rouge">UITableViewDeleagte</code> 里方法的源对象。</p>
</blockquote>

<p>All methods take the delegate’s source object as the first argument.</p>

<p>所有方法将代理源对象作为第一个实参。</p>

<p>For methods that take the delegate’s source object as their <strong>only</strong> argument:</p>

<p>对于<strong>只</strong>有代理源对象实参的方法：</p>

<ul>
  <li>
    <p>If the method returns <code class="highlighter-rouge">Void</code> (such as those used to notify the delegate that
an event has occurred), then the method’s base name is the <strong>delegate’s
source type</strong> followed by an <strong>indicative verb phrase</strong> describing the
event. The argument is <strong>unlabeled.</strong></p>
  </li>
  <li>
    <p>如果方法返回 <code class="highlighter-rouge">void</code>（例如用于提醒代理事件发生），那么方法名为<strong>代理源类型</strong>后面加上描述事件的<strong>指示性动词</strong>。实参<strong>无标签</strong>。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">scrollViewDidBeginScrolling</span><span class="p">(</span><span class="n">_</span> <span class="nv">scrollView</span><span class="p">:</span> <span class="kt">UIScrollView</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>If the method returns <code class="highlighter-rouge">Bool</code> (such as those that make an assertion about the
delegate’s source object itself), then the method’s name is the <strong>delegate’s
source type</strong> followed by an <strong>indicative or conditional verb phrase</strong>
describing the assertion. The argument is <strong>unlabeled.</strong></p>
  </li>
  <li>
    <p>如果方法返回 <code class="highlighter-rouge">Bool</code>（例如对代理源对象本身做断言），那么方法名为<strong>代理源类型</strong>后面加上描述断言的<strong>指示性或条件性动词</strong>。实参<strong>无标签</strong>。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">scrollViewShouldScrollToTop</span><span class="p">(</span><span class="n">_</span> <span class="nv">scrollView</span><span class="p">:</span> <span class="kt">UIScrollView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>If the method returns some other value (such as those querying for
information about a property of the delegate’s source object), then the
method’s base name is a <strong>noun phrase</strong> describing the property being
queried. The argument is <strong>labeled with a preposition or phrase with a
trailing preposition</strong> that appropriately combines the noun phrase and the
delegate’s source object.</p>
  </li>
  <li>
    <p>如果方法返回其他值（例如查询代理源对象上的属性信息），那么方法名是描述查询属性的<strong>名词</strong>。实参<strong>标签是介词或后置介词</strong>，用于将名词和代理源对象合适地连接起来。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">numberOfSections</span><span class="p">(</span><span class="k">in</span> <span class="nv">scrollView</span><span class="p">:</span> <span class="kt">UIScrollView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>For methods that take <strong>additional</strong> arguments after the delegate’s source
object, the method’s base name is the delegate’s source type <strong>by itself</strong> and
the first argument is <strong>unlabeled.</strong> Then:</p>

<p>对于在代理源对象后有<strong>额外</strong>实参的方法，方法名是代理源类型<strong>自身</strong>并且第一个实参<strong>无标签</strong>。然后：</p>

<ul>
  <li>
    <p>If the method returns <code class="highlighter-rouge">Void</code>, the second argument is <strong>labeled with an
indicative verb phrase</strong> describing the event that has the argument as its
<strong>direct object or prepositional object,</strong> and any other arguments (if
present) provide further context.</p>
  </li>
  <li>
    <p>如果方法返回 <code class="highlighter-rouge">void</code>，第二个实参<strong>标签是指示性动词</strong>，用于描述实参是<strong>直接宾语或者间接宾语</strong>的事件，并给其它实参（如果有的话）提供更多上下文。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span>
<span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
  <span class="n">willDisplayCell</span> <span class="nv">cell</span><span class="p">:</span> <span class="kt">UITableViewCell</span><span class="p">,</span>
  <span class="n">forRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>If the method returns <code class="highlighter-rouge">Bool</code>, the second argument is <strong>labeled with an
indicative or conditional verb phrase</strong> that describes the return value in
terms of the argument, and any other arguments (if present) provide further
context.</p>
  </li>
  <li>
    <p>如果方法返回 <code class="highlighter-rouge">Bool</code>，第二个实参<strong>标签是指示性或者条件性动词</strong>，用于描述对于实参的返回值，并给其他实参（如果有的话）提供更多上下文。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span>
<span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
  <span class="n">shouldSpringLoadRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span><span class="p">,</span>
  <span class="n">with</span> <span class="nv">context</span><span class="p">:</span> <span class="kt">UISpringLoadedInteractionContext</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>If the method returns some other value, the second argument is <strong>labeled
with a noun phrase and trailing preposition</strong> that describes the return
value in terms of the argument, and any other arguments (if present) provide
further context.</p>
  </li>
  <li>
    <p>如果方法返回其他值，第二个实参<strong>标签是名词和后置介词</strong>，用于描述对于实参的返回值，并给其他实参（如果有的话）提供更多上下文。</p>

    <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span>
<span class="n">_</span> <span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span>
  <span class="n">heightForRowAt</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">IndexPath</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">CGFloat</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>Apple’s documentation on
<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/CocoaEncyclopedia/DelegatesandDataSources/DelegatesandDataSources.html">delegates and data sources</a>
also contains some good general guidance about such names.</p>

<p>Apple 的 <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/DelegatesandDataSources/DelegatesandDataSources.html">代理和数据源</a> 文档也提供了一些在这种情况下的通用命名指引。</p>

<h2 id="编程实践programming-practices">编程实践/Programming Practices</h2>

<p>Common themes among the rules in this section are: avoid redundancy, avoid
ambiguity, and prefer implicitness over explicitness unless being explicit
improves readability and/or reduces ambiguity.</p>

<p>本章节中规则的通用主旨是：避免冗余，避免歧义，除了能明显提高可读性和/或减少歧义外尽量使用隐式而不是显式。</p>

<h3 id="编译器警告compiler-warnings">编译器警告/Compiler Warnings</h3>

<p>Code should compile without warnings when feasible. Any warnings that are able
to be removed easily by the author must be removed.</p>

<p>代码在编译时尽可能保持没有警告。任何可以简单去除的警告作者都应该去除。</p>

<p>A reasonable exception is deprecation warnings, where it may not be possible to
immediately migrate to the replacement API, or where an API may be deprecated
for external users but must still be supported inside a library during a
deprecation period.</p>

<p>在不可能马上迁移到替代 API 时或者在 API 对外部用户废弃但还需要继续对库内部支持的废弃时期，有理由的废弃警告可以例外。</p>

<h3 id="构造器initializers-1">构造器/Initializers</h3>

<p>For <code class="highlighter-rouge">struct</code>s, Swift synthesizes a non-public memberwise <code class="highlighter-rouge">init</code> that takes
arguments for <code class="highlighter-rouge">var</code> properties and for any <code class="highlighter-rouge">let</code> properties that lack default
values. When that initializer is suitable (that is, a <code class="highlighter-rouge">public</code> one is not
needed), it is used and no explicit initializer is written.</p>

<p>对于 <code class="highlighter-rouge">Struct</code>，Swift 会合成实参为 <code class="highlighter-rouge">var</code> 属性和缺少默认值的 <code class="highlighter-rouge">let</code> 属性的非公开逐一成员 <code class="highlighter-rouge">init</code>。如果该构造器已经足够（也就是说不需要 <code class="highlighter-rouge">public</code> 的话），直接使用而不需要书写显式的构造器。</p>

<p>The initializers declared by the special <code class="highlighter-rouge">ExpressibleBy*Literal</code> compiler
protocols are never called directly.</p>

<p>遵循特殊的 <code class="highlighter-rouge">ExpressibleBy*Literal</code> 编译器协议而声明的构造器永远不应该直接调用。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Kilometers</span><span class="p">:</span> <span class="kt">ExpressibleByIntegerLiteral</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">integerLiteral</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">k1</span><span class="p">:</span> <span class="kt">Kilometers</span> <span class="o">=</span> <span class="mi">10</span>                          <span class="c1">// GOOD.</span>
<span class="k">let</span> <span class="nv">k2</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">as</span> <span class="kt">Kilometers</span>                        <span class="c1">// ALSO GOOD.</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Kilometers</span><span class="p">:</span> <span class="kt">ExpressibleByIntegerLiteral</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">integerLiteral</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">k</span> <span class="o">=</span> <span class="kt">Kilometers</span><span class="p">(</span><span class="nv">integerLiteral</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>           <span class="c1">// AVOID.</span>
</code></pre></div></div>

<p>Explicitly calling <code class="highlighter-rouge">.init(...)</code> is allowed only when the receiver of the call is
a metatype variable. In direct calls to the initializer using the literal type
name, <code class="highlighter-rouge">.init</code> is omitted. (<strong>Referring</strong> to the initializer directly by using
<code class="highlighter-rouge">MyType.init</code> syntax to convert it to a closure is permitted.)</p>

<p>只有当调用者是元类型变量时才允许明确调用  <code class="highlighter-rouge">.init(...)</code>  。使用字面量类型名字直接调用构造器时，省略 <code class="highlighter-rouge">.init</code>。（构造器使用 <code class="highlighter-rouge">MyType.init</code> 语法作为闭包进行<strong>引用</strong>是允许的。）</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">MyType</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">type</span> <span class="o">=</span> <span class="nf">lookupType</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="n">type</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="nf">makeValue</span><span class="p">(</span><span class="nv">factory</span><span class="p">:</span> <span class="kt">MyType</span><span class="o">.</span><span class="kd">init</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">x</span> <span class="o">=</span> <span class="kt">MyType</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="属性properties-1">属性/Properties</h3>

<p>The <code class="highlighter-rouge">get</code> block for a read-only computed property is omitted and its body is
directly nested inside the property declaration.</p>

<p>只读计算属性的 <code class="highlighter-rouge">get</code> 块可以省略，并将执行体直接嵌套在属性声明里。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">totalCost</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="n">sum</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">cost</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">totalCost</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">get</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="n">sum</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">cost</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="类型简称types-with-shorthand-names">类型简称/Types with Shorthand Names</h3>

<p>Arrays, dictionaries, and optional types are written in their shorthand form
whenever possible; that is, <code class="highlighter-rouge">[Element]</code>, <code class="highlighter-rouge">[Key: Value]</code>, and <code class="highlighter-rouge">Wrapped?</code>. The
long forms <code class="highlighter-rouge">Array&lt;Element&gt;</code>, <code class="highlighter-rouge">Dictionary&lt;Key, Value&gt;</code>, and <code class="highlighter-rouge">Optional&lt;Wrapped&gt;</code>
are only written when required by the compiler; for example, the Swift parser
requires <code class="highlighter-rouge">Array&lt;Element&gt;.Index</code> and does not accept <code class="highlighter-rouge">[Element].Index</code>.</p>

<p>数组，字典和可选类型尽可能使用简写形式，也就是 <code class="highlighter-rouge">[Element]</code>，<code class="highlighter-rouge">[Key: Value]</code> 和 <code class="highlighter-rouge">Wrapped?</code>。完整形式 <code class="highlighter-rouge">Array&lt;Element&gt;</code>，<code class="highlighter-rouge">Dictionary&lt;Key, Value&gt;</code> 和 <code class="highlighter-rouge">Optional&lt;Wrapped&gt;</code> 只有在编译器需要时才使用，例如 Swift 语法分析程序不接受 <code class="highlighter-rouge">[Element].Index</code> 而需要用 <code class="highlighter-rouge">Array&lt;Element&gt;.Index</code>。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">enumeratedDictionary</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">from</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Element</span><span class="p">],</span>
  <span class="nv">start</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;.</span><span class="kt">Index</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">:</span> <span class="kt">Element</span><span class="p">]</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">enumeratedDictionary</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">(</span>
  <span class="n">from</span> <span class="nv">values</span><span class="p">:</span> <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nv">start</span><span class="p">:</span> <span class="kt">Optional</span><span class="o">&lt;</span><span class="kt">Array</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;.</span><span class="kt">Index</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Void</code> is a <code class="highlighter-rouge">typealias</code> for the empty tuple <code class="highlighter-rouge">()</code>, so from an implementation
point of view they are equivalent. In function type declarations (such as
closures, or variables holding a function reference), the return type is always
written as <code class="highlighter-rouge">Void</code>, never as <code class="highlighter-rouge">()</code>. In functions declared with the <code class="highlighter-rouge">func</code> keyword,
the <code class="highlighter-rouge">Void</code> return type is omitted entirely.</p>

<p><code class="highlighter-rouge">Void</code> 是空元组 <code class="highlighter-rouge">()</code> 的 <code class="highlighter-rouge">typealias</code>，所以从实现来说它们是等价的。在函数类型声明（例如闭包或者持有函数引用变量）的返回类型永远写作 <code class="highlighter-rouge">void</code>，而不用 <code class="highlighter-rouge">()</code>。在用 <code class="highlighter-rouge">func</code> 关键字声明的函数中，全都省略 <code class="highlighter-rouge">void</code> 返回类型。</p>

<p>Empty argument lists are always written as <code class="highlighter-rouge">()</code>, never as <code class="highlighter-rouge">Void</code>. (In fact,
the function signature <code class="highlighter-rouge">Void -&gt; Result</code> is an error in Swift because function
arguments must be surrounded by parentheses, and <code class="highlighter-rouge">(Void)</code> has a different
meaning: an argument list with a single empty-tuple argument.)</p>

<p>空的实参列表永远写作 <code class="highlighter-rouge">()</code>，而不是 <code class="highlighter-rouge">Void</code>。（事实上， <code class="highlighter-rouge">Void -&gt; Result</code> 的函数签名在 Swift 里会报错，因为函数实参必须用括号包围，而 <code class="highlighter-rouge">(void)</code> 有着其他含义：单个空元组实参的实参列表。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">callback</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Void</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doSomething2</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">callback</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span>
</code></pre></div></div>

<h3 id="可选类型optional-types">可选类型/Optional Types</h3>

<p>Sentinel values are avoided when designing algorithms (for example, an “index”
of −1 when an element was not found in a collection). Sentinel values can
easily and accidentally propagate through other layers of logic because the type
system cannot distinguish between them and valid outcomes.</p>

<p>在设计算法时避免哨兵值（例如使用 -1 的 “索引” 表示集合里找不到某个元素）。哨兵值容易被偶然传递到其它逻辑层，因为类型系统没办法将它们和合法结果进行区分。</p>

<p><code class="highlighter-rouge">Optional</code> is used to convey a non-error result that is either a value or the
absence of a value. For example, when searching a collection for a value, not
finding the value is still a <strong>valid and expected</strong> outcome, not an error.</p>

<p><code class="highlighter-rouge">Optional</code> 用于值和缺省值其中之一的表达，是非错误结果。例如：在集合中查询一个值时，值没有找到是一个<strong>合法并可预期</strong>的结果，而不是一个错误。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">index</span><span class="p">(</span><span class="n">of</span> <span class="nv">thing</span><span class="p">:</span> <span class="kt">Thing</span><span class="p">,</span> <span class="k">in</span> <span class="nv">things</span><span class="p">:</span> <span class="p">[</span><span class="kt">Thing</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">?</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">if</span> <span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">thing</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="n">lotsOfThings</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Found it.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// Didn't find it.</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">index</span><span class="p">(</span><span class="n">of</span> <span class="nv">thing</span><span class="p">:</span> <span class="kt">Thing</span><span class="p">,</span> <span class="k">in</span> <span class="nv">things</span><span class="p">:</span> <span class="p">[</span><span class="kt">Thing</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">index</span> <span class="o">=</span> <span class="nf">index</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">thing</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="n">lotsOfThings</span><span class="p">)</span>
<span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
  <span class="c1">// Found it.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// Didn't find it.</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Optional</code> is also used for error scenarios when there is a single, obvious
failure state; that is, when an operation may fail for a single domain-specific
reason that is clear to the client. (The domain-specific restriction is meant to
exclude severe errors that are typically out of the user’s control to properly
handle, such as out-of-memory errors.)</p>

<p><code class="highlighter-rouge">Optional</code> 也用于表示单一而明确失败的错误哨兵，也就是当操作是因为使用者明确的单个特定领域原因而失败时。（限制在特定领域是为了排除那些用户明显无法正确处理的严重错误，例如内存不足错误。）</p>

<p>For example, converting a string to an integer would fail if the
string does not represent a valid integer that fits into the type’s bit width:</p>

<p>例如，如果字符串不能用适合类型位宽的合法整数表达，将字符串转换为整型可能会失败：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Int17</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">?(</span><span class="n">_</span> <span class="nv">string</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Conditional statements that test that an <code class="highlighter-rouge">Optional</code> is non-<code class="highlighter-rouge">nil</code> but do not
access the wrapped value are written as comparisons to <code class="highlighter-rouge">nil</code>. The following
example is clear about the programmer’s intent:</p>

<p>判断一个 <code class="highlighter-rouge">Optional</code> 是否非 <code class="highlighter-rouge">nil</code> 但不需要访问解包值时，条件语句用和 <code class="highlighter-rouge">nil</code> 比较的形式。下面的例子能清晰地表达程序意图：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">value</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"value was not nil"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This example, while taking advantage of Swift’s pattern matching and binding
syntax, obfuscates the intent by appearing to unwrap the value and then
immediately throw it away.</p>

<p>这个例子里，如果利用 Swift 模式匹配和绑定语法，将值解包后马上丢弃，会混淆程序意图。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="k">let</span> <span class="nv">_</span> <span class="o">=</span> <span class="n">value</span> <span class="p">{</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"value was not nil"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="错误类型error-types">错误类型/Error Types</h3>

<p>Error types are used when there are multiple possible error states.</p>

<p>错误类型在错误有多种可能得状态时使用。</p>

<p>Throwing errors instead of merging them with the return type cleanly separates
concerns in the API. Valid inputs and valid state produce valid outputs in the
result domain and are handled with standard sequential control flow. Invalid
inputs and invalid state are treated as errors and are handled using the
relevant syntactic constructs (<code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">catch</code> and <code class="highlighter-rouge">try</code>). For example:</p>

<p>将错误抛出而不是随着返回值返回可以更清晰地将问题从 API 里分离。合法输入和合法状态在结果域里产生合法输出，并通过标准的控制流进行处理。非法输入和非法状态应视作错误，并使用相关语法结构进行处理（<code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">catch</code> 和 <code class="highlighter-rouge">try</code>）。例如：</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Document</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="kt">ReadError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">notFound</span>
    <span class="k">case</span> <span class="n">permissionDenied</span>
    <span class="k">case</span> <span class="n">malformedHeader</span>
  <span class="p">}</span>

  <span class="nf">init</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">do</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">document</span> <span class="o">=</span> <span class="k">try</span> <span class="kt">Document</span><span class="p">(</span><span class="nv">path</span><span class="p">:</span> <span class="s">"important.data"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="kt">Document</span><span class="o">.</span><span class="kt">ReadError</span><span class="o">.</span><span class="n">notFound</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="kt">Document</span><span class="o">.</span><span class="kt">ReadError</span><span class="o">.</span><span class="n">permissionDenied</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Such a design forces the caller to consciously acknowledge the failure case by:</p>

<p>下面这样的设计能迫使调用者有意识地面对错误：</p>

<ul>
  <li>wrapping the calling code in a <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">catch</code> block and handling error cases to
whichever degree is appropriate,</li>
  <li>将代码包在 <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">catch</code> 块里调用，并根据错误严重程度进行处理，</li>
  <li>declaring the function in which the call is made as <code class="highlighter-rouge">throws</code> and letting the
error propagate out, or</li>
  <li>将函数声明为在调用时 <code class="highlighter-rouge">throws</code> 并将错误传递给上层，或者</li>
  <li>using <code class="highlighter-rouge">try?</code> when the specific reason for failure is unimportant and only the
information about whether the call failed is needed.</li>
  <li>在某些不重要失败原因并且只需要调用是否失败的信息时使用 <code class="highlighter-rouge">try?</code> 。</li>
</ul>

<p>In general, with exceptions noted below, force-<code class="highlighter-rouge">try!</code> is forbidden; it is
equivalent to <code class="highlighter-rouge">try</code> followed by <code class="highlighter-rouge">fatalError</code> but without a meaningful message.
If an error outcome would mean that the program is in such an unrecoverable
state that immediate termination is the only reasonable action, it is better to
use <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">catch</code> or <code class="highlighter-rouge">try?</code> and provide more context in the error message to
assist debugging if the operation does fail.</p>

<p>通常来说，除了下面的说明以外，强制-<code class="highlighter-rouge">try!</code> 是禁止的；它等同于对 <code class="highlighter-rouge">fatalError</code> 使用 <code class="highlighter-rouge">try</code> 但却没有有意义的信息。如果某个错误的发生意味着程序处在无法恢复的状态，那么立即终止是唯一合理的动作，这时使用 <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">catch</code> 或者 <code class="highlighter-rouge">try?</code> 并提供错误的更多上下文信息，可以更好地帮助调试。</p>

<blockquote>
  <p><strong>Exception:</strong> Force-<code class="highlighter-rouge">try!</code> is allowed in unit tests and test-only code. It is
also allowed in non-test code when it is unmistakably clear that an error
would only be thrown because of <strong>programmer</strong> error; we specifically define
this to mean a single expression that could be evaluated without context in
the Swift REPL. For example, consider initializing a regular expression from a
a string literal:</p>

  <p><strong>例外：</strong>强制-<code class="highlighter-rouge">try!</code> 在单元测试和仅用于测试的代码是允许使用的。也可以在非测试代码里使用，在错误抛出非常明确只可能是由<strong>编程人员</strong>导致时；我们特别定义这种情况，是因为在 Swift REPL 里有些单个表达式没有上下文就无法被推断。例如，考虑通过字符串字面量来构造正则表达式的情况：</p>

  <div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">regex</span> <span class="o">=</span> <span class="k">try!</span> <span class="kt">NSRegularExpression</span><span class="p">(</span><span class="nv">pattern</span><span class="p">:</span> <span class="s">"a*b+c?"</span><span class="p">)</span>
</code></pre></div>  </div>

  <p>The <code class="highlighter-rouge">NSRegularExpression</code> initializer throws an error if the regular
expression is malformed, but when it is a string literal, the error would only
occur if the programmer mistyped it. There is no benefit to writing extra
error handling logic here.</p>

  <p><code class="highlighter-rouge">NSRegularExpression</code> 构造器会在正则表达式不合法时抛出错误，但当它是字符串字面量时，错误只可能由于编程人员的编写错误导致。这时候编写额外的错误处理逻辑并没有什么益处。</p>

  <p>If the pattern above were not a literal but instead were dynamic or derived
from user input, <code class="highlighter-rouge">try!</code> should <strong>not</strong> be used and errors should be handled
gracefully.</p>

  <p>如果上面 pattern 不是字面量，而是动态生成的或者是使用者传入的，则<strong>不</strong>应该使用 <code class="highlighter-rouge">try!</code> ，而应该更优雅地处理出现的错误。</p>
</blockquote>

<h3 id="强制解包和强制擦除force-unwrapping-and-force-casts">强制解包和强制擦除/Force Unwrapping and Force Casts</h3>

<p>Force-unwrapping and force-casting are often code smells and are strongly
discouraged. Unless it is extremely clear from surrounding code why such an
operation is safe, a comment should be present that describes the invariant that
ensures that the operation is safe. For example,</p>

<p>强制解包和强制擦除通常意味着有代码异味和被强迫进行妥协。除非它能通过周围代码解释清楚该操作的安全性，并需要附加注释来描述这个操作是永远安全的。例如，</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="nf">getSomeInteger</span><span class="p">()</span>

<span class="c1">// ...intervening code...</span>

<span class="c1">// This force-unwrap is safe because `value` is guaranteed to fall within the</span>
<span class="c1">// valid enum cases because it came from some data source that only permits</span>
<span class="c1">// those raw values.</span>
<span class="k">return</span> <span class="kt">SomeEnum</span><span class="p">(</span><span class="nv">rawValue</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span><span class="o">!</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Exception:</strong> Force-unwraps are allowed in unit tests and test-only code
without additional documentation. This keeps such code free of unnecessary
control flow. In the event that <code class="highlighter-rouge">nil</code> is unwrapped or a cast operation is to
an incompatible type, the test will fail which is the desired result.</p>

  <p><strong>例外：</strong>在单元测试和仅用于测试的代码里允许没有附加注释的强制解包。这可以减少代码不必要的控制流。在 <code class="highlighter-rouge">nil</code> 被解包或者不合适的类型擦除发生时，测试也会按照预期而失败。</p>
</blockquote>

<h3 id="可选值隐式解包implicitly-unwrapped-optionals">可选值隐式解包/Implicitly Unwrapped Optionals</h3>

<p>Implicitly unwrapped optionals are inherently unsafe and should be avoided
whenever possible in favor of non-optional declarations or regular <code class="highlighter-rouge">Optional</code>
types. Exceptions are described below.</p>

<p>可选值隐式解包有潜在的不安全之处，当可以用非可选值声明或者习惯的 <code class="highlighter-rouge">Optional</code> 类型时就应该避免。除了下面描述的情况外。</p>

<p>User-interface objects whose lifetimes are based on the UI lifecycle instead of
being strictly based on the lifetime of the owning object are allowed to use
implicitly unwrapped optionals. Examples of these include <code class="highlighter-rouge">@IBOutlet</code>
properties connected to objects in a XIB file or storyboard, properties that are
initialized externally like in the <code class="highlighter-rouge">prepareForSegue</code> implementation of a calling
view controller, and properties that are initialized elsewhere during a class’s
life cycle, like views in a view controller’s <code class="highlighter-rouge">viewDidLoad</code> method. Making such
properties regular optionals can put too much burden on the user to unwrap them
because they are guaranteed to be non-nil and remain that way once the objects
are ready for use.</p>

<p>存活时间基于 UI 生命周期而不是严格基于持有关系的用户界面元素可以使用可选值显式解包。这种情况的例子包括连接 XIB 文件或 storyboard 中元素的 <code class="highlighter-rouge">@IBOutlet</code> 属性，显式初始化的属性，例如在 <code class="highlighter-rouge">prepareForSegue</code> 实现里调用的 view controller，还有在类生命周期以外时间点会被初始化的属性，例如在 view controller <code class="highlighter-rouge">viewDidLoad</code> 方法里的视图。这些属性如果用习惯的可选值会加重使用者解包的负担，因为它们能确保非空并且一旦已经准备好被使用就会一直保持在这种状态。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomeViewController</span><span class="p">:</span> <span class="kt">UIViewController</span> <span class="p">{</span>
  <span class="kd">@IBOutlet</span> <span class="k">var</span> <span class="nv">button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="o">!</span>

  <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">populateLabel</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">button</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">private</span> <span class="kd">func</span> <span class="nf">populateLabel</span><span class="p">(</span><span class="k">for</span> <span class="nv">button</span><span class="p">:</span> <span class="kt">UIButton</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Implicitly unwrapped optionals can also surface in Swift code when using
Objective-C APIs that lack the appropriate nullability attributes. If possible,
coordinate with the owners of that code to add those annotations so that the
APIs are imported cleanly into Swift. If this is not possible, try to keep the
footprint of those implicitly unwrapped optionals as small as possible in your
Swift code; that is, do not propagate them through multiple layers of your own
abstractions.</p>

<p>可选值隐式解包也会在 Swift 代码使用缺少恰当判空特性的 Objective-C API 时出现。如果可能，和该代码的拥有者商量添加上那些注解，该 API 在 Swift 就可以更清晰的引入。如果没有可能，尽可能尝试将这些可选值隐式解包在 Swift 代码中的影响缩小 ；也就是说，不要将它们扩散到多个你自己的抽象层。</p>

<p>Implicitly unwrapped optionals are also allowed in unit tests. This is for
reasons similar to the UI object scenario above—the lifetime of test
fixtures often begins not in the test’s initializer but in the <code class="highlighter-rouge">setUp()</code> method
of a test so that they can be reset before the execution of each test.</p>

<p>可选值隐式解包在单元测试也被允许。这和上面的 UI 元素情况理由差不多——测试里对象的生命周期通常不从测试构造器开始，而是从测试的 <code class="highlighter-rouge">setUp()</code> 方法开始，以便在每次测试执行前重置。</p>

<h3 id="访问等级access-levels">访问等级/Access Levels</h3>

<p>Omitting an explicit access level is permitted on declarations. For top-level
declarations, the default access level is <code class="highlighter-rouge">internal</code>. For nested declarations,
the default access level is the lesser of <code class="highlighter-rouge">internal</code> and the access level of the
enclosing declaration.</p>

<p>在声明里省略显式的访问等级是允许的。顶层声明的默认访问等级是 <code class="highlighter-rouge">internal</code>。嵌套的声明默认访问等级和其外层声明访问等级相同但不能高于 <code class="highlighter-rouge">internal</code> 。</p>

<p>Specifying an explicit access level at the file level on an extension is
forbidden. Each member of the extension has its access level specified if it is
different than the default.</p>

<p>给文件级别的扩展指定显式访问等级是不允许的。拓展里的每一个成员如果不采用默认的访问等级则应该单独进行指定。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="k">var</span> <span class="nv">isUppercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="kd">public</span> <span class="k">var</span> <span class="nv">isLowercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">extension</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">isUppercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">isLowercase</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="嵌套和命名空间nesting-and-namespacing">嵌套和命名空间/Nesting and Namespacing</h3>

<p>Swift allows <code class="highlighter-rouge">enum</code>s, <code class="highlighter-rouge">struct</code>s, and <code class="highlighter-rouge">class</code>es to be nested, so nesting is
preferred (instead of naming conventions) to express scoped and hierarchical
relationships among types when possible. For example, flag <code class="highlighter-rouge">enum</code>s or error
types that are associated with a specific type are nested in that type.</p>

<p>Swift 里允许嵌套 <code class="highlighter-rouge">enum</code>，<code class="highlighter-rouge">struct</code> 和 <code class="highlighter-rouge">class</code>，所以在可能时，嵌套更适合（比起命名约定）表示作用域和类型之间的分级关系。例如，在类型里嵌套特定类型的 <code class="highlighter-rouge">enum</code> 作标志或者错误类型。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Parser</span> <span class="p">{</span>
  <span class="kd">enum</span> <span class="kt">Error</span><span class="p">:</span> <span class="kt">Swift</span><span class="o">.</span><span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">invalidToken</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">unexpectedEOF</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Parser</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">enum</span> <span class="kt">ParseError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nf">invalidToken</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">unexpectedEOF</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Swift does not currently allow protocols to be nested in other types or vice
versa, so this rule does not apply to situations such as the relationship
between a controller class and its delegate protocol.</p>

<p>Swift 目前还不支持嵌套协议在其它类型中，反之亦然，所以该规则不适用于解决例如控制器类型和它代理协议之间的关系。</p>

<p>Declaring an <code class="highlighter-rouge">enum</code> without cases is the canonical way to define a “namespace”
to group a set of related declarations, such as constants or helper functions.
This <code class="highlighter-rouge">enum</code> automatically has no instances and does not require that extra
boilerplate code be written to prevent instantiation.</p>

<p>声明一个没有 case 的 <code class="highlighter-rouge">enum</code> 是定义用于相关声明分组的“命名空间”的公认方案，例如常量或者帮助方法。该 <code class="highlighter-rouge">enum</code> 会自然而然不存在实例并且不需要额外样板代码来避免可被实例化。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Dimensions</span> <span class="p">{</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileMargin</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tilePadding</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileContentSize</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Dimensions</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileMargin</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">8</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tilePadding</span><span class="p">:</span> <span class="kt">CGFloat</span> <span class="o">=</span> <span class="mi">4</span>
  <span class="kd">static</span> <span class="k">let</span> <span class="nv">tileContentSize</span><span class="p">:</span> <span class="kt">CGSize</span><span class="p">(</span><span class="nv">width</span><span class="p">:</span> <span class="mi">80</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span> <span class="mi">64</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="提前退出的-guardguards-for-early-exits">提前退出的 <code class="highlighter-rouge">guard</code>/<code class="highlighter-rouge">guard</code>s for Early Exits</h3>

<p>A <code class="highlighter-rouge">guard</code> statement, compared to an <code class="highlighter-rouge">if</code> statement with an inverted condition,
provides visual emphasis that the condition being tested is a special case that
causes early exit from the enclosing scope.</p>

<p><code class="highlighter-rouge">guard</code> 语句，比起条件相反的 <code class="highlighter-rouge">if</code> 语句，会更好地从视觉上强调该检查条件是导致从外层作用域提前退出的特例。</p>

<p>Furthermore, <code class="highlighter-rouge">guard</code> statements improve readability by eliminating extra levels
of nesting (the “pyramid of doom”); failure conditions are closely coupled to
the conditions that trigger them and the main logic remains flush left within
its scope.</p>

<p>更远了说，<code class="highlighter-rouge">guard</code> 语句通过减少额外嵌套层级（“鞭尸金字塔”）来提高可读性；令错误情况和触发条件靠近，而主逻辑在作用域里保持向左对齐。</p>

<p>This can be seen in the following examples; in the first, there is a clear
progression that checks for invalid states and exits, then executes the main
logic in the successful case. In the second example without <code class="highlighter-rouge">guard</code>, the main
logic is buried at an arbitrary nesting level and the thrown errors are
separated from their conditions by a great distance.</p>

<p>下面的例子中会体现这些理论；第一种例子里，有清晰的流程，检查不合法的状态并退出，然后在成功的情况下执行主逻辑。在没有 <code class="highlighter-rouge">guard</code> 的第二个例子里，主逻辑混杂在某个任意嵌套层级里，抛出的错误和它们的触发条件被分隔得很开。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">discombobulate</span><span class="p">(</span><span class="n">_</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">guard</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">first</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">arrayWasEmpty</span>
  <span class="p">}</span>
  <span class="k">guard</span> <span class="n">first</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">negativeEnergy</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">values</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="nf">invertedCombobulatoryFactory</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">discombobulate</span><span class="p">(</span><span class="n">_</span> <span class="nv">values</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">first</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">first</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="k">var</span> <span class="nv">result</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">values</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="nf">invertedCombobulatoryFactor</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">negativeEnergy</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="kt">DiscombobulationError</span><span class="o">.</span><span class="n">arrayWasEmpty</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A <code class="highlighter-rouge">guard</code>-<code class="highlighter-rouge">continue</code> statement can also be useful in a loop to avoid increased
indentation when the entire body of the loop should only be executed in some
cases (but see also the <code class="highlighter-rouge">for</code>-<code class="highlighter-rouge">where</code> discussion below.)</p>

<p><code class="highlighter-rouge">guard</code>-<code class="highlighter-rouge">continue</code> 语句也可以避免循环的整个循环体只在某些情况下执行时缩进增加（但也可以看看下面 <code class="highlighter-rouge">for</code>-<code class="highlighter-rouge">where</code> 的讨论）。</p>

<h3 id="for-where-循环for-where-loops"><code class="highlighter-rouge">for</code>-<code class="highlighter-rouge">where</code> 循环/<code class="highlighter-rouge">for</code>-<code class="highlighter-rouge">where</code> Loops</h3>

<p>When the entirety of a <code class="highlighter-rouge">for</code> loop’s body would be a single <code class="highlighter-rouge">if</code> block testing a
condition of the element, the test is placed in the <code class="highlighter-rouge">where</code> clause of the <code class="highlighter-rouge">for</code>
statement instead.</p>

<p>当整个 <code class="highlighter-rouge">for</code> 循环体只包含了对元素的条件检查 <code class="highlighter-rouge">if</code> 块时，可以将该检查可以放在 <code class="highlighter-rouge">for</code> 语句里 <code class="highlighter-rouge">where</code> 分句中。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">collection</span> <span class="k">where</span> <span class="n">item</span><span class="o">.</span><span class="n">hasProperty</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">collection</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">hasProperty</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="在-switch-语句里的-fallthrough-fallthrough-in-switch-statements">在 <code class="highlighter-rouge">switch</code> 语句里的 <code class="highlighter-rouge">fallthrough</code>/ <code class="highlighter-rouge">fallthrough</code> in <code class="highlighter-rouge">switch</code> Statements</h3>

<p>When multiple <code class="highlighter-rouge">case</code>s of a <code class="highlighter-rouge">switch</code> would execute the same statements, the
<code class="highlighter-rouge">case</code> patterns are combined into ranges or comma-delimited lists. Multiple
<code class="highlighter-rouge">case</code> statements that do nothing but <code class="highlighter-rouge">fallthrough</code> to a <code class="highlighter-rouge">case</code> below are not
allowed.</p>

<p>当 <code class="highlighter-rouge">switch</code> 里的多个 <code class="highlighter-rouge">case	</code> 执行同样的语句时，这些 <code class="highlighter-rouge">case</code> 可以合并成一个范围或者逗号分隔的列表。声明多个 <code class="highlighter-rouge">case</code> 却不做任何事只 <code class="highlighter-rouge">fallthrough</code> 到下面 <code class="highlighter-rouge">case</code> 是不允许的。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">value</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">2</span><span class="o">...</span><span class="mi">4</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"two to four"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"five or seven"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span> <span class="k">break</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">value</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"one"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="k">fallthrough</span>
<span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="k">fallthrough</span>
<span class="k">case</span> <span class="mi">4</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"two to four"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">5</span><span class="p">:</span> <span class="k">fallthrough</span>
<span class="k">case</span> <span class="mi">7</span><span class="p">:</span> <span class="nf">print</span><span class="p">(</span><span class="s">"five or seven"</span><span class="p">)</span>
<span class="k">default</span><span class="p">:</span> <span class="k">break</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In other words, there is never a <code class="highlighter-rouge">case</code> whose body contains <em>only</em> the
<code class="highlighter-rouge">fallthrough</code> statement. Cases containing <em>additional</em> statements which then
fallthrough to the next case are permitted.</p>

<p>也就是说，不能有_只_执行 <code class="highlighter-rouge">fallthrough</code> 语句的 <code class="highlighter-rouge">case</code> 。包含_其余_语句再贯穿到下一个的 case 是允许的。</p>

<h3 id="模式匹配pattern-matching">模式匹配/Pattern Matching</h3>

<p>The <code class="highlighter-rouge">let</code> and <code class="highlighter-rouge">var</code> keywords are placed individually in front of <em>each</em> element
in a pattern that is being matched. The shorthand version of <code class="highlighter-rouge">let</code>/<code class="highlighter-rouge">var</code> that
precedes and distributes across the entire pattern is forbidden because it can
introduce unexpected behavior if a value being matched in a pattern is itself a
variable.</p>

<p>_每个_模式匹配元素前面都有单独的 <code class="highlighter-rouge">let</code> 和 <code class="highlighter-rouge">var</code> 关键字。适用于整个匹配模式的前置简写 <code class="highlighter-rouge">let</code>/<code class="highlighter-rouge">var</code> 是禁止的，因为当匹配模式的值本身是个变量时，会引入非预期行为。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">DataPoint</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nf">unlabeled</span><span class="p">(</span><span class="kt">Int</span><span class="p">)</span>
  <span class="k">case</span> <span class="nf">labeled</span><span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">let</span> <span class="nv">label</span> <span class="o">=</span> <span class="s">"goodbye"</span>

<span class="c1">// `label` is treated as a value here because it is not preceded by `let`, so</span>
<span class="c1">// the pattern below matches only data points that have the label "goodbye".</span>
<span class="k">switch</span> <span class="kt">DataPoint</span><span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="k">let</span> <span class="nv">value</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// Writing `let` before each individual binding clarifies that the intent is to</span>
<span class="c1">// introduce a new binding (shadowing the local variable within the case) rather</span>
<span class="c1">// than to match against the value of the local variable. Thus, this pattern</span>
<span class="c1">// matches data points with any string label.</span>
<span class="k">switch</span> <span class="kt">DataPoint</span><span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="k">let</span> <span class="nv">label</span><span class="p">,</span> <span class="k">let</span> <span class="nv">value</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the example below, if the author’s intention was to match using the value of
the <code class="highlighter-rouge">label</code> variable above, that has been lost because <code class="highlighter-rouge">let</code> distributes across
the entire pattern and thus shadows the variable with a binding that applies to
any string value:</p>

<p>在下面的例子中，如果作者意图是使用上面的 <code class="highlighter-rouge">label</code> 变量进行匹配，那么就会因为 <code class="highlighter-rouge">let</code> 适用于整个模式匹配，从而该值会被任何绑定的字符串所覆盖。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="kt">DataPoint</span><span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">labeled</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Labels of tuple arguments and <code class="highlighter-rouge">enum</code> associated values are omitted when binding
a value to a variable with the same name as the label.</p>

<p>元组的实参标签和 <code class="highlighter-rouge">enum</code> 的关联值在用相同标签名字的变量来绑定值时可以被省略。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">subtree</span><span class="p">(</span><span class="nv">left</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">BinaryTree</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="k">case</span> <span class="nf">leaf</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="kt">Element</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">switch</span> <span class="n">treeNode</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">subtree</span><span class="p">(</span><span class="k">let</span> <span class="nv">left</span><span class="p">,</span> <span class="k">let</span> <span class="nv">right</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="k">let</span> <span class="nv">element</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Including the labels adds noise that is redundant and lacking useful
information:</p>

<p>包含多余并缺乏有用信息的标签只会造成混淆：</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">switch</span> <span class="n">treeNode</span> <span class="p">{</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">subtree</span><span class="p">(</span><span class="nv">left</span><span class="p">:</span> <span class="k">let</span> <span class="nv">left</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="k">let</span> <span class="nv">right</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="k">case</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="nv">element</span><span class="p">:</span> <span class="k">let</span> <span class="nv">element</span><span class="p">):</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="元组模式tuple-patterns">元组模式/Tuple Patterns</h3>

<p>Assigning variables through a tuple pattern (sometimes referred to as a <em>tuple
shuffle</em>) is only permitted if the left-hand side of the assignment is
unlabeled.</p>

<p>只有赋值表达式左侧没有标签的元组模式（有时候用_乱序元组_）变量赋值才被允许。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">x</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">let</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">a</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">x</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span>
</code></pre></div></div>

<p>Labels on the left-hand side closely resemble type annotations, and can lead to
confusing code.</p>

<p>左侧的标签与类型注解很类似，会导致代码难以理解。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This declares two variables, `Int`, which is a `Double` with value 5.0, and</span>
<span class="c1">// `Double`, which is an `Int` with value 4.</span>
<span class="c1">// `x` and `y` are not variables.</span>
<span class="nf">let</span> <span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nv">y</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">x</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="数字和字符串字面量numeric-and-string-literals">数字和字符串字面量/Numeric and String Literals</h3>

<p>Integer and string literals in Swift do not have an intrinsic type. For example,
<code class="highlighter-rouge">5</code> by itself is not an <code class="highlighter-rouge">Int</code>; it is a special literal value that can express
any type that conforms to <code class="highlighter-rouge">ExpressibleByIntegerLiteral</code> and only becomes an
<code class="highlighter-rouge">Int</code> if type inference does not map it to a more specific type. Likewise, the
literal <code class="highlighter-rouge">"x"</code> is neither <code class="highlighter-rouge">String</code> nor <code class="highlighter-rouge">Character</code> nor <code class="highlighter-rouge">UnicodeScalar</code>, but it
can become any of those types depending on its context, falling back to <code class="highlighter-rouge">String</code>
as a default.</p>

<p>Swift 里的整型和字符串字面量没有固定类型。例如，<code class="highlighter-rouge">5</code> 本身不是一个 <code class="highlighter-rouge">Int</code>；它是能被 <code class="highlighter-rouge">ExpressibleByIntegerLiteral</code> 解释成任意类型的特殊字面量值，并且如果类型推断没有把它转换为更具体的类型，就会变成 <code class="highlighter-rouge">Int</code> 值。类似的，字面量<code class="highlighter-rouge">"x"</code>并不是 <code class="highlighter-rouge">String</code>， <code class="highlighter-rouge">Character</code> 或  <code class="highlighter-rouge">UnicodeScalar</code>，不过它可以根据上下文变成这些类型，默认情况是变成 <code class="highlighter-rouge">String</code>。</p>

<p>Thus, when a literal is used to initialize a value of a type other than its
default, and when that type cannot be inferred otherwise by context, specify the
type explicitly in the declaration or use an <code class="highlighter-rouge">as</code> expression to coerce it.</p>

<p>因此类型在使用默认以外的字面量方式构造值，并且该类型不能通过上下文推断更多信息时，需要在声明里用显式类型或者用 <code class="highlighter-rouge">as</code> 表达式来进行强制转换。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Without a more explicit type, x1 will be inferred as type Int.</span>
<span class="k">let</span> <span class="nv">x1</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1">// These are explicitly type Int32.</span>
<span class="k">let</span> <span class="nv">x2</span><span class="p">:</span> <span class="kt">Int32</span> <span class="o">=</span> <span class="mi">50</span>
<span class="k">let</span> <span class="nv">x3</span> <span class="o">=</span> <span class="mi">50</span> <span class="k">as</span> <span class="kt">Int32</span>

<span class="c1">// Without a more explicit type, y1 will be inferred as type String.</span>
<span class="k">let</span> <span class="nv">y1</span> <span class="o">=</span> <span class="s">"a"</span>

<span class="c1">// These are explicitly type Character.</span>
<span class="k">let</span> <span class="nv">y2</span><span class="p">:</span> <span class="kt">Character</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="k">let</span> <span class="nv">y3</span> <span class="o">=</span> <span class="s">"a"</span> <span class="k">as</span> <span class="kt">Character</span>

<span class="c1">// These are explicitly type UnicodeScalar.</span>
<span class="k">let</span> <span class="nv">y4</span><span class="p">:</span> <span class="kt">UnicodeScalar</span> <span class="o">=</span> <span class="s">"a"</span>
<span class="k">let</span> <span class="nv">y5</span> <span class="o">=</span> <span class="s">"a"</span> <span class="k">as</span> <span class="kt">UnicodeScalar</span>

<span class="kd">func</span> <span class="nf">writeByte</span><span class="p">(</span><span class="n">_</span> <span class="nv">byte</span><span class="p">:</span> <span class="kt">UInt8</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// Inference also occurs for function arguments, so 50 is a UInt8 without</span>
<span class="c1">// explicitly coercion.</span>
<span class="nf">writeByte</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
</code></pre></div></div>

<p>The compiler will emit errors appropriately for invalid literal coercions if,
for example, a number does not fit into the integer type or a multi-character
string is coerced to a character. So while the following examples emit errors,
they are “good” because the errors are caught at compile-time and for the right
reasons.</p>

<p>如果字面量的强制转换不合理，编译器会抛出合适的错误，例如，数字不属于整型类型或者强制转换为字符的多字符的字符串时。所以下面例子抛出错误是“好”事，因为这些错误在编译期就找到了正确的错因。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// error: integer literal '9223372036854775808' overflows when stored into 'Int64'</span>
<span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="mh">0x8000_0000_0000_0000</span> <span class="k">as</span> <span class="kt">Int64</span>

<span class="c1">// error: cannot convert value of type 'String' to type 'Character' in coercion</span>
<span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="s">"ab"</span> <span class="k">as</span> <span class="kt">Character</span>
</code></pre></div></div>

<p>Using initializer syntax for these types of coercions can lead to misleading
compiler errors, or worse, hard-to-debug runtime errors.</p>

<p>这些类型使用构造器语法进行强制转换的话会产生易误导的编译器错误，或者可能更糟糕，产生难调试的运行时错误。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This first tries to create an `Int` (signed) from the literal and then</span>
<span class="c1">// convert it to a `UInt64`. Even though this literal fits into a `UInt64`, it</span>
<span class="c1">// doesn't fit into an `Int` first, so it doesn't compile.</span>
<span class="k">let</span> <span class="nv">a1</span> <span class="o">=</span> <span class="kt">UInt64</span><span class="p">(</span><span class="mh">0x8000_0000_0000_0000</span><span class="p">)</span>

<span class="c1">// This invokes `Character.init(_: String)`, thus creating a `String` "a" at</span>
<span class="c1">// runtime (which involves a slow heap allocation), extracting the character</span>
<span class="c1">// from it, and then releasing it. This is significantly slower than a proper</span>
<span class="c1">// coercion.</span>
<span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="kt">Character</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span>

<span class="c1">// As above, this creates a `String` and then `Character.init(_: String)`</span>
<span class="c1">// attempts to extract the single character from it. This fails a precondition</span>
<span class="c1">// check and traps at runtime.</span>
<span class="k">let</span> <span class="nv">c</span> <span class="o">=</span> <span class="kt">Character</span><span class="p">(</span><span class="s">"ab"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="playground-字面量playground-literals">Playground 字面量/Playground Literals</h3>

<p>The graphically-rendered playground literals <code class="highlighter-rouge">#colorLiteral(...)</code>,
<code class="highlighter-rouge">#imageLiteral(...)</code>, and <code class="highlighter-rouge">#fileLiteral(...)</code> are forbidden in non-playground
production code. They are permitted in playground sources.</p>

<p>会进行图形渲染的 playground 字面量 <code class="highlighter-rouge">#colorLiteral(...)</code>，<code class="highlighter-rouge">#imageLiteral(...)</code> 和 <code class="highlighter-rouge">#fileLiteral(...)</code> 在非 playground 的代码里是禁止的。它们只允许在 playground 源码里。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">color</span> <span class="o">=</span> <span class="kt">UIColor</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">color</span> <span class="o">=</span> <span class="err">#</span><span class="nf">colorLiteral</span><span class="p">(</span><span class="nv">red</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">green</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">blue</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nv">alpha</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="捕获溢出运算trapping-vs-overflowing-arithmetic">捕获溢出运算/Trapping vs. Overflowing Arithmetic</h3>

<p>The standard (trapping-on-overflow) arithmetic and bitwise operators (<code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">-</code>,
<code class="highlighter-rouge">*</code>, <code class="highlighter-rouge">&lt;&lt;</code>, and <code class="highlighter-rouge">&gt;&gt;</code>) are used for most normal operations, rather than the
masking operations (preceded by <code class="highlighter-rouge">&amp;</code>). Trapping on overflow is safer because it
prevents bad data from propagating through other layers of the system.</p>

<p>标准（捕获溢出）运算和二元运算符（<code class="highlighter-rouge">+</code>，<code class="highlighter-rouge">-</code>，<code class="highlighter-rouge">*</code>，<code class="highlighter-rouge">&lt;&lt;</code> 和 <code class="highlighter-rouge">&gt;&gt;</code>）大部分用于普通操作，而非掩码操作（前置 <code class="highlighter-rouge">&amp;</code>）。捕获溢出会更加安全，因为它防止错误数据被传递到系统的其他层级。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// GOOD. Overflow will not cause the balance to go negative.</span>
<span class="k">let</span> <span class="nv">newBankBalance</span> <span class="o">=</span> <span class="n">oldBankBalance</span> <span class="o">+</span> <span class="n">recentHugeProfit</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// AVOID. Overflow will cause the balance to go negative if the summands are</span>
<span class="c1">// large.</span>
<span class="k">let</span> <span class="nv">newBankBalance</span> <span class="o">=</span> <span class="n">oldBankBalance</span> <span class="o">&amp;+</span> <span class="n">recentHugeProfit</span>
</code></pre></div></div>

<p>Masking operations are comparatively rare but are permitted (and in fact
necessary for correctness) in problem domains that use modular arithmetic, such
as cryptography, big-integer implementations, hash functions, and so forth.</p>

<p>掩码操作比较少见，但在模数运算的问题领域是允许的（事实上为了正确性是必要的），例如加密，大整型实现，哈希函数等等。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">hashValue</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// GOOD. What matters here is the distribution of the bit pattern rather than</span>
  <span class="c1">// the actual numeric value.</span>
  <span class="k">return</span> <span class="n">foo</span><span class="o">.</span><span class="n">hashValue</span> <span class="o">&amp;+</span> <span class="mi">31</span> <span class="o">*</span> <span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">hashValue</span> <span class="o">&amp;+</span> <span class="mi">31</span> <span class="o">&amp;*</span> <span class="n">baz</span><span class="o">.</span><span class="n">hashValue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">hashValue</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// INCORRECT. This will trap arbitrarily and unpredictably depending on the</span>
  <span class="c1">// hash values of the individual terms.</span>
  <span class="k">return</span> <span class="n">foo</span><span class="o">.</span><span class="n">hashValue</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">*</span> <span class="p">(</span><span class="n">bar</span><span class="o">.</span><span class="n">hashValue</span> <span class="o">+</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">baz</span><span class="o">.</span><span class="n">hashValue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Masking operations are also permitted in performance-sensitive code where the
values are already known to not cause overflow (or where overflow is not a
concern). In this case, comments should be used to indicate why the use of
masking operations is important. Additionally, consider adding debug
preconditions to check these assumptions without affecting performance of
optimized builds.</p>

<p>掩码操作在确保值不会导致溢出（或者不需要担心溢出）的性能敏感代码里也是允许的。在这种情况下，需要使用注释来注明使用掩码操作的重要性。更进一步，在不影响性能优化的情况下，考虑增加先决调试条件来检查这些假设。</p>

<h3 id="定义新运算符defining-new-operators">定义新运算符/Defining New Operators</h3>

<p>When used unwisely, custom-defined operators can significantly reduce the
readability of code because such operators often lack the historical context of
the more common ones built into the standard library.</p>

<p>不理智地使用自定义运算符会显著影响代码可读性，因为这样的运算符比起标准库中更常用的运算符，通常缺乏历史背景。</p>

<p>In general, defining custom operators should be avoided. However, it is allowed
when an operator has a clear and well-defined meaning in the problem domain
and when using an operator significantly improves the readability of the code
when compared to function calls. For example, since <code class="highlighter-rouge">*</code> is the only
multiplication operator defined by Swift (not including the masking version), a
numeric matrix library may define additional operators to support other
operations like cross product and dot product.</p>

<p>通常来说，应该避免自定义运算符。然而，当一个运算符在问题领域中有清晰和含义良好的定义，并且使用它会比函数调用显著提高代码的可读性时，是允许的。例如，<code class="highlighter-rouge">*</code> 在 Swift 里只定义为乘法运算符（不包含掩码版本）， 数学矩阵库可能会定义额外的运算符来支持其他运算比如叉乘和点乘。</p>

<p>An example of a prohibited use case is defining custom <code class="highlighter-rouge">&lt;~~</code> and <code class="highlighter-rouge">~~&gt;</code> operators
to decode and encode JSON data. Such operators are not native to the problem
domain of processing JSON and even an experienced Swift engineer would have
difficulty understanding the purpose of the code without seeking out
documentation of those operators.</p>

<p>禁止用法其中一种例子是定义自定义 <code class="highlighter-rouge">&lt;~~</code> 和 <code class="highlighter-rouge">~~&gt;</code> 运算符来解码和编码 JSON 数据。这样的运算符不是 JSON 领域问题的原生处理方式，甚至连有经验的 Swift 工程师在没有这些运算符文档的情况下也可能会对这种处理代码有着不同的理解。</p>

<p>If you must use third-party code of unquestionable value that provides an API
only available through custom operators, you are <strong>strongly encouraged</strong> to
consider writing a wrapper that defines more readable methods that delegate to
the custom operators. This will significantly reduce the learning curve required
to understand how such code works for new teammates and other code reviewers.</p>

<p>如果你一定要让没问题的值使用第三方代码里只提供了自定义运算符形式的 API，<strong>强烈建议</strong>你编写一个包装器，定义可读性更好的方法作为该自定义运算符的代理。对团队新成员或者其他代码审查者来说，这会显著降低理解这样的代码是如何工作的学习曲线。</p>

<h3 id="重载已存在运算符overloading-existing-operators">重载已存在运算符/Overloading Existing Operators</h3>

<p>Overloading operators is permitted when your use of the operator is semantically
equivalent to the existing uses in the standard library. Examples of permitted
use cases are implementing the operator requirements for <code class="highlighter-rouge">Equatable</code> and
<code class="highlighter-rouge">Hashable</code>, or defining a new <code class="highlighter-rouge">Matrix</code> type that supports arithmetic operations.</p>

<p>用语义上和标准库中已存在等同的重载运算符是允许的。允许的例子是为 <code class="highlighter-rouge">Equatable</code> 和 <code class="highlighter-rouge">Hashable</code> 实现运算符要求，或者定义新的 <code class="highlighter-rouge">Matrix</code> 类型来支持算数运算。</p>

<p>If you wish to overload an existing operator with a meaning other than its
natural meaning, follow the guidance in
<a href="#defining-new-operators">Defining New Operators</a> to determine whether this is
permitted. In other words, if the new meaning is well-established in the problem
domain and the use of the operator is a readability improvement over other
syntactic constructs, then it is permitted.</p>

<p>如果你希望用和原本不同的含义重载已存在的运算符，参考 <a href="#defining-new-operators">定义新运算符</a> 指引来确定是否允许。也就是说，如果新的含义在问题领域是确定已久的，并且使用该运算符会比其他语法结构提高可读性，那么就是允许的。</p>

<p>An example of a prohibited case of operator repurposing would be to overload <code class="highlighter-rouge">*</code>
and <code class="highlighter-rouge">+</code> to build an ad hoc regular expression API. Such an API would not provide
strong enough readability benefits compared to simply representing the entire
regular expression as a string.</p>

<p>禁止更改运算符含义的一种例子是重载 <code class="highlighter-rouge">*</code> 和 <code class="highlighter-rouge">+</code> 来构建特定正则表达式的 API。这样的 API 没有比简单用字符串表示整个正则表达式的方式可读性强很多。</p>

<h2 id="文档注释documentation-comments">文档注释/Documentation Comments</h2>

<h3 id="通常格式general-format">通常格式/General Format</h3>

<p>Documentation comments are written using the format where each line is preceded
by a triple slash (<code class="highlighter-rouge">///</code>). Javadoc-style block comments (<code class="highlighter-rouge">/** ... */</code>) are not
permitted.</p>

<p>文档注释使用每行前面三个斜杠（<code class="highlighter-rouge">///</code>）的格式。Java 文档风格的块状注释（<code class="highlighter-rouge">/** ...*/</code>）是不允许的。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Returns the numeric value of the given digit represented as a Unicode scalar.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - digit: The Unicode scalar whose numeric value should be returned.</span>
<span class="c1">///   - radix: The radix, between 2 and 36, used to compute the numeric value.</span>
<span class="c1">/// - Returns: The numeric value of the scalar.</span>
<span class="kd">func</span> <span class="nf">numericValue</span><span class="p">(</span><span class="n">of</span> <span class="nv">digit</span><span class="p">:</span> <span class="kt">UnicodeScalar</span><span class="p">,</span> <span class="nv">radix</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Returns the numeric value of the given digit represented as a Unicode scalar.
 *
 * - Parameters:
 *   - digit: The Unicode scalar whose numeric value should be returned.
 *   - radix: The radix, between 2 and 36, used to compute the numeric value.
 * - Returns: The numeric value of the scalar.
 */</span>
<span class="kd">func</span> <span class="nf">numericValue</span><span class="p">(</span><span class="n">of</span> <span class="nv">digit</span><span class="p">:</span> <span class="kt">UnicodeScalar</span><span class="p">,</span> <span class="nv">radix</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="cm">/**
Returns the numeric value of the given digit represented as a Unicode scalar.

- Parameters:
  - digit: The Unicode scalar whose numeric value should be returned.
  - radix: The radix, between 2 and 36, used to compute the numeric value.
- Returns: The numeric value of the scalar.
*/</span>
<span class="kd">func</span> <span class="nf">numericValue</span><span class="p">(</span><span class="n">of</span> <span class="nv">digit</span><span class="p">:</span> <span class="kt">UnicodeScalar</span><span class="p">,</span> <span class="nv">radix</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="一句话概括single-sentence-summary">一句话概括/Single-Sentence Summary</h3>

<p>Documentation comments begin with a brief <strong>single-sentence</strong> summary that
describes the declaration. (This sentence may span multiple lines, but if it
spans too many lines, the author should consider whether the summary can be
simplified and details moved to a new paragraph.)</p>

<p>文档注释的开始使用简短的<strong>一句话</strong>概括来描述声明。（这句话可以跨行，但如果跨了很多行，作者应该考虑是否可以将概况简化并将细节移到新的段落中。）</p>

<p>If more detail is needed than can be stated in the summary, additional
paragraphs (each separated by a blank line) are added after it.</p>

<p>如果概括需要陈述更多细节，在后面添加额外的段落（每个段落用空行分隔）。</p>

<p>The single-sentence summary is not necessarily a complete sentence; for example,
method summaries are generally written as verb phrases <strong>without</strong> “this method
[…]” because it is already implied as the subject and writing it out would be
redundant. Likewise, properties are often written as noun phrases <strong>without</strong>
“this property is […]”. In any case, however, they are still terminated with a
period.</p>

<p>一句话概括不需要是完整的句子；例如，方法的概括通常写作动词短语，<strong>不需要</strong>加上“这个方法 […]”，因为这就是要表达的，写出来是多余的。类似，属性通常写作名词短语，<strong>不需要</strong>加上“这个属性是 […]”。然而无论如何，它们还是要以句号结尾。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// The background color of the view.</span>
<span class="k">var</span> <span class="nv">backgroundColor</span><span class="p">:</span> <span class="kt">UIColor</span>

<span class="c1">/// Returns the sum of the numbers in the given array.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameter numbers: The numbers to sum.</span>
<span class="c1">/// - Returns: The sum of the numbers.</span>
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// This property is the background color of the view.</span>
<span class="k">var</span> <span class="nv">backgroundColor</span><span class="p">:</span> <span class="kt">UIColor</span>

<span class="c1">/// This method returns the sum of the numbers in the given array.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameter numbers: The numbers to sum.</span>
<span class="c1">/// - Returns: The sum of the numbers.</span>
<span class="kd">func</span> <span class="nf">sum</span><span class="p">(</span><span class="n">_</span> <span class="nv">numbers</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="形参返回值和抛出标签parameter-returns-and-throws-tags">形参，返回值和抛出标签/Parameter, Returns, and Throws Tags</h3>

<p>Clearly document the parameters, return value, and thrown errors of functions
using the <code class="highlighter-rouge">Parameter(s)</code>, <code class="highlighter-rouge">Returns</code>, and <code class="highlighter-rouge">Throws</code> tags, in that order. None ever
appears with an empty description. When a description does not fit on a single
line, continuation lines are indented 2 spaces in from the position of the
hyphen starting the tag.</p>

<p>对形参，返回值和函数抛出的错误按照 <code class="highlighter-rouge">Parameter(s)</code>，<code class="highlighter-rouge">Returns</code> 和 <code class="highlighter-rouge">Throws</code> 标签的顺序清晰地写下文档。不要出现空白的描述。当一个描述需要换行时，续行的缩进在开始的标记连字符基础上加上 2 个空格。</p>

<p>The recommended way to write documentation comments in Xcode is to place the
text cursor on the declaration and press <strong>Command + Option + /</strong>. This will
automatically generate the correct format with placeholders to be filled in.</p>

<p>Xcode 里编写文档注释的推荐方式是将文字光标放在声明上并且按下 <strong>Command + Option + /</strong>。这会自动创建有待填充占位符的正确格式注释。</p>

<p><code class="highlighter-rouge">Parameter(s)</code> and <code class="highlighter-rouge">Returns</code> tags may be omitted only if the single-sentence
brief summary fully describes the meaning of those items and including the tags
would only repeat what has already been said.</p>

<p><code class="highlighter-rouge">Parameter(s)</code> 和 <code class="highlighter-rouge">Returns</code> 标签只有当一句话简短概括中已经有完整描述时可以省略，如果还包括它们就只是重复已经说过的内容。</p>

<p>The content following the <code class="highlighter-rouge">Parameter(s)</code>, <code class="highlighter-rouge">Returns</code>, and <code class="highlighter-rouge">Throws</code> tags should be
terminated with a period, even when they are phrases instead of complete
sentences.</p>

<p><code class="highlighter-rouge">Parameter(s)</code>，<code class="highlighter-rouge">Returns</code> 和 <code class="highlighter-rouge">Throws</code> 标签后面跟着的内容需要以句号结尾，即使它们只是短语而不是完整的句子。</p>

<p>When a method takes a single argument, the singular inline form of the
<code class="highlighter-rouge">Parameter</code> tag is used. When a method takes multiple arguments, the grouped
plural form <code class="highlighter-rouge">Parameters</code> is used and each argument is written as an item in a
nested list with only its name as the tag.</p>

<p>当方法只有单一的实参时，使用内联单数形式的 <code class="highlighter-rouge">Parameter</code> 标签。当方法有多个实参时，使用分组复数形式 <code class="highlighter-rouge">Parameters</code>，嵌套列表里用每个实参的名字作标签。</p>

<div class="language-swift good highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Returns the output generated by executing a command.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameter command: The command to execute in the shell environment.</span>
<span class="c1">/// - Returns: A string containing the contents of the invoked process's</span>
<span class="c1">///   standard output.</span>
<span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">command</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">/// Returns the output generated by executing a command with the given string</span>
<span class="c1">/// used as standard input.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - command: The command to execute in the shell environment.</span>
<span class="c1">///   - stdin: The string to use as standard input.</span>
<span class="c1">/// - Returns: A string containing the contents of the invoked process's</span>
<span class="c1">///   standard output.</span>
<span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">command</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">stdin</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The following examples are incorrect, because they use the plural form of
<code class="highlighter-rouge">Parameters</code> for a single parameter or the singular form <code class="highlighter-rouge">Parameter</code> for
multiple parameters.</p>

<p>下面的例子是错误的，因为它们对单个形参使用复数形式 <code class="highlighter-rouge">Parameters</code> 或者对多个形参使用单数形式 <code class="highlighter-rouge">Parameter</code>。</p>

<div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Returns the output generated by executing a command.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameters:</span>
<span class="c1">///   - command: The command to execute in the shell environment.</span>
<span class="c1">/// - Returns: A string containing the contents of the invoked process's</span>
<span class="c1">///   standard output.</span>
<span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">command</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">/// Returns the output generated by executing a command with the given string</span>
<span class="c1">/// used as standard input.</span>
<span class="c1">///</span>
<span class="c1">/// - Parameter command: The command to execute in the shell environment.</span>
<span class="c1">/// - Parameter stdin: The string to use as standard input.</span>
<span class="c1">/// - Returns: A string containing the contents of the invoked process's</span>
<span class="c1">///   standard output.</span>
<span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nv">command</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">stdin</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="apple-标记格式apples-markup-format">Apple 标记格式/Apple’s Markup Format</h3>

<p>Use of
<a href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/">Apple’s markup format</a>
is strongly encouraged to add rich formatting to documentation. Such markup
helps to differentiate symbolic references (like parameter names) from
descriptive text in comments and is rendered by Xcode and other documentation
generation tools. Some examples of frequently used directives are listed below.</p>

<p>强烈建议使用 <a href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/">Apple 标记格式</a> 来添加富文本到文档中。这种标记有助于区分注释里的特征引用（例如形参名字）和描述性文本，并且可以被 Xcode 和其他文档生成工具渲染。下面列出一些常用指令的示例。</p>

<ul>
  <li>Paragraphs are separated using a single line that starts with <code class="highlighter-rouge">///</code> and is
otherwise blank.</li>
  <li>段落以 <code class="highlighter-rouge">///</code> 开始的单一空白行分隔。</li>
  <li><em>*Single asterisks*</em> and <em>_single underscores_</em> surround text that should
be rendered in italic/oblique type.</li>
  <li>以<em>*单星号*</em>和__单下划线__包围的文本会被渲染成斜体/斜型。</li>
  <li><strong>**Double asterisks**</strong> and <strong>__double underscores__</strong> surround text
that should be rendered in boldface.</li>
  <li>以<strong>**双星号**</strong>和____双下划线____包围的文本会被渲染成粗体。</li>
  <li>Names of symbols or inline code are surrounded in <code class="highlighter-rouge">`backticks`</code>.</li>
  <li>符号名或者内联代码以 <code class="highlighter-rouge">`反引号`</code>包围。</li>
  <li>Multi-line code (such as example usage) is denoted by placing three backticks
(<code class="highlighter-rouge"> </code>`` `) on the lines before and after the code block.</li>
  <li>多行代码（例如作为用例）以三个反引号（<code class="highlighter-rouge"> </code>`` `）的行开头和结束。</li>
</ul>

<h3 id="注释的位置where-to-document">注释的位置/Where to Document</h3>

<p>At a minimum, documentation comments are present for every open or public
declaration, and every open or public member of such a declaration, with
specific exceptions noted below:</p>

<p>最起码，每个 open 或 public 声明和里面的每个 open 或 public 成员都应该有文档注释，除了下面的说明以外：</p>

<ul>
  <li>
    <p>Individual cases of an <code class="highlighter-rouge">enum</code> often are not documented if their meaning is
self-explanatory from their name. Cases with associated values, however,
should document what those values mean if it is not obvious.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">enum</code> 里单个的 case 的名字如果已经可以自解释则通常不需要注释。有关联值的 Case 如果值的含义不明确，那么不管怎样都应该注释。</p>
  </li>
  <li>
    <p>A documentation comment is not always present on a declaration that overrides
a supertype declaration or implements a protocol requirement, or on a
declaration that provides the default implementation of a protocol requirement
in an extension.</p>

    <p>It is acceptable to document an overridden declaration to describe new
behavior from the declaration that it overrides. In no case should the
documentation for the override be a mere copy of the base declaration’s
documentation.</p>
  </li>
  <li>
    <p>继承父类的声明，协议要求的实现或者提供协议要求的默认实现的扩展声明可以不需要文档注释。</p>

    <p>继承声明里用来描述继承后的新表现的注释是可以接受的。任何情况下都不应该出现单纯拷贝父声明文档的注释。</p>
  </li>
  <li>
    <p>A documentation comment is not always present on test classes and test
methods. However, they can be useful for functional test classes and for
helper classes/methods shared by multiple tests.</p>
  </li>
  <li>
    <p>测试类和测试方法可以不需要文档注释。然而，注释对于在多个测试里复用的函数式测试类和帮助类/方法时是有帮助的。</p>
  </li>
  <li>
    <p>A documentation comment is not always present on an extension declaration
(that is, the <code class="highlighter-rouge">extension</code> itself). You may choose to add one if it help
clarify the purpose of the extension, but avoid meaningless or misleading
comments.</p>

    <p>In the following example, the comment is just repetition of what is already
obvious from the source code:</p>
  </li>
  <li>
    <p>扩展声明（也就是自身的 <code class="highlighter-rouge">extension</code>）可以不需要文档注释。如果能帮助明确拓展的用途，你可以选择添加，但避免无意义或者误导的注释。</p>

    <p>在下面的例子中，注释仅仅重复了源码显而易见的事：</p>

    <div class="language-swift bad highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Add `Equatable` conformance.</span>
<span class="kd">extension</span> <span class="kt">MyType</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>The next example is more subtle, but it is an example of documentation that is
not scalable because the extension or the conformance could be updated in the
future. Consider that the type may be made <code class="highlighter-rouge">Comparable</code> at the time of that
writing in order to sort the values, but that is not the only possible use of
that conformance and client code could use it for other purposes in the
future.</p>

    <p>下面的例子则更微妙一些，但这是一个注释无法拓展的例子，因为这个拓展或者类型一致性在以后可能会变化。这个 <code class="highlighter-rouge">Comparable</code> 可能是在编写对该类型值的排序代码时加上的，但这不是一致性的唯一可能用途，并且使用者可能在以后其他用途代码里会依赖它。</p>

    <div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">/// Make `Candidate` comparable so that they can be sorted.</span>
<span class="kd">extension</span> <span class="kt">Candidate</span><span class="p">:</span> <span class="kt">Comparable</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>In general, if you find yourself writing documentation that simply repeats
information that is obvious from the source and sugaring it with words like
“a representation of,” then leave the comment out entirely.</p>

<p>通常来说，如果你发现你写的注释只是简单地重复源码中显而易见的事，并用类似”用于表示”的词语进行美化，那么将这些注释完全去掉。</p>

<p>However, it is <em>not</em> appropriate to cite this exception to justify omitting
relevant information that a typical reader might need to know. For example, for
a property named <code class="highlighter-rouge">canonicalName</code>, don’t omit its documentation (with the
rationale that it would only say <code class="highlighter-rouge">/// The canonical name.</code>) if a typical reader
may have no idea what the term “canonical name” means in that context. Use the
documentation as an opportunity to define the term.</p>

<p>但是，<em>不</em>要用这个例外来证明可以省略某些正常读者可能需要的相关信息。例如，对于 <code class="highlighter-rouge">canonicalName</code> 名字的属性，不要省略注释（只有合理的时候才可以只写 <code class="highlighter-rouge">/// The canonical name.</code>），因为正常读者可能不知道术语“规范名字”在上下文中的含义。 使用注释是定义该术语的好机会。</p>

</article>

  </main>

  <footer class="site-footer">

  <div class="wrapper">

  </div>

</footer>


  <script src="https://swift.org/assets/javascripts/application.js"></script>
</body>

</html>
